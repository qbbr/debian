#!/bin/bash
########################################################################
####  Script Name: simple/system graphics installer: sgfxi
####  Debian Sid, Testing, and Stable graphic driver install.
####  New: Ubuntu support in progress. Arch/Fedora Support under development
####  version: 4.15.16
####  Date: October 31 2010
########################################################################
####  Copyright (C) Harald Hope 2007-2010
####  Code contributions copyright: Latino 2008
####  Contributors: ati card driver and xorg configuration in general: damentz and d2kx
####  This program is free software; you can redistribute it and/or modify it under
####  the terms of the GNU General Public License as published by the Free Software
####  Foundation; either version 2 of the License, or (at your option) any later version.
####
####  This program is distributed in the hope that it will be useful, but WITHOUT
####  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
####  FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
####
####  Get the full text of the GPL here: http://www.gnu.org/licenses/gpl.txt
########################################################################
####  Script URL: http://smxi.org/sg/sgfxi
####  Script SVN: http://code.google.com/p/sgfxi
####  Script Documentation: http://smxi.org/docs/
####  Script Home page: http://techpatterns.com/forums/about933.html
########################################################################
#### DEFINE:
#### TRUE: -eq 0; == 'true'; function return 0
#### FALSE: -gt 0; == ''; function return > 0
########################################################################
####  CONVENTIONS:
####  Indentation: TABS
####  Do not use `....`, those are totally non-reabable, use $(....)
####  Do not use one liner flow controls. The ONLY time you should use ; is in
####  this single case: if [ condition ];then (ie, never: [ condition ] && statement)
####
####  All new code/methods must be in a function.
####  For all boolean tests, use 'true' / 'false'. Do NOT use 0 or 1 unless
####  it's a function return. Avoid complicated tests in the if condition itself.
####
####  VARIABLE/FUNCTION NAMING:
####  All variables should explain what they are, except counters like i, j
####  All variables MUST be initialized / declared explicitly
####, globals UPPER CASE, at top of script, SOME_VARIABLE='' (words separated by _ ).
####  Locals always: local someVariable= (lower case, all except first word started upper case)
####  and at the top of the function. ie: testTrunkData
####
####  Booleans should start with b_ or B_ and state clearly what is being tested
####	Arrays should start with a_ or A_
####  All functions should follow standard naming, ie, verb adjective noun, get_cpu_data
########################################################################
####  TESTING FLAGS
####  sgfxi supports advanced testing triggers to do various things, using -! <arg>
####  -! 1 - triggers default B_TESTING_1='true' - triggers testing data function
####  -! 2 - triggers default B_TESTING_2='true' - triggers post test exit
####  -! 3 - triggers default B_SKIP_FUNCTION='true' to turn off functions for script testing
####  -! 4 - triggers B_TESTING_1='true' and B_TESTING_2='true'
####  -! 5 - triggers B_TESTING_1='true', B_TESTING_2='true', and B_SKIP_FUNCTION='true'
####  -! 6 - triggers B_TESTING_3='true' - overrides xorg/kernel support tests
####  -! 7 - triggers B_TESTING_5='true' - triggers advanced, beta tests for general script
####  -! 8 - triggers B_TESTING_4='true' - overrides patch tests
####  -! 9 - triggers B_TESTING_6='true' - triggers new distro development tests
####  -! 10 - triggers an update from the primary dev download server
####  -! 11 - triggers an update from svn branch one - if present, of course
####  -! 12 - triggers an update from svn branch two - if present, of course
####  -! <http://......> - Triggers an update from whatever server you list.
####  -! 20 - uses patch from svn branch one server (must be in branch/one/patches)
####  -! 21 - uses patch from svn branch two server (must be in branch/two/patches)
########################################################################
####  EXTRA DATA
####  Cross referenced table of package manager commands (apt/yum/pacman etc):
####  http://www.archlinux.it/wiki/index.php?title=Pacman_rosetta
########################################################################
#### VARIABLES
########################################################################

## Distro maintainers: set these variables to meet your needs ##
# maintainers can turn this to false to stop allowing script auto updates. Only set
# to false if this script will be packaged and you want to not allow script auto updates
B_ALLOW_AUTO_UPDATE='true'
# maintainers change this to script default path please to keep things simple if different
SCRIPT_HOME='/usr/local/bin'
SCRIPT_NAME='sgfxi'
SCRIPT_WORKING_DIR="/usr/src/$SCRIPT_NAME-downloads"
SM_KERNEL_DOWNLOADS='/usr/src/sm-kernel-downloads'

# script global data
NON_DEBIAN_PATTERN='(deb-ats|deb-mep|deb-mm|deb-op|deb-sdx|deb-skp|deb-swift|deb-vb|alphagemini|aptosid|byteme|cathbard|debian-multimedia|dotdeb|edevelop|eeepc|freevo|giss.tv|google|java|kanotix|kde|kiberpipa|kplayer|lamaresh|liquorix|lxde|mepis|moblock|opera|noreply|prodeia.de|rarewares|rox4debian|sidux|skype|swiftfox|tovid|videolan|virtualbox|wine-hq|xadras)'

APT_TYPE='apt-get'
CARD='' # card type: fglrx or nvidia
DISTRIB_CODENAME=''
DISTRIB_ID=''
DISTRIB_RELEASE=''
FED_KERNEL_PAE=''
NON_FREE_DRIVER=''
SYSTEM_BASE=''
SYSTEM_CODENAME=''
NATIVE_OVERRIDE=''
# this is the actual pattern that will be used to search for this stuff in script
#NATIVE_OVERRIDE_SUPPORTED='ati|i128|i740|i810|i810-modesetting|intel|mga|neomagic|nv|openchrome|radeon|radeonhd|sis|tdfx|vesa|via|vga|voodoo'
NATIVE_OVERRIDE_SUPPORTED='apm|ark|ati|chips|cirrus|cyrix|fbdev|glint|i128|i740|intel|i810|imstt|mach64|mga|neomagic|nsc|nv|openchrome|nouveau|radeon|radeonhd|rendition|s3|s3virge|savage|siliconmotion|sis|sisusb|tdfx|tga|trident|tseng|vesa|vga|via|voodoo|vmware|v4l'
PACKAGE_MANAGER=''
# options: 0 - monochrome; 1 default; more coming?
SCRIPT_COLORS=1
START_OPTIONS_PRINT='' # for output to user of what options they used
START_OPTIONS=''
WITHOUT_RECOMMENDS=''
X_NAME=''

## main script boolean switches
B_AUTORUN='false'
B_BETA_EXISTS='false'
B_BUILD_KERNEL_MODULES='false'
B_COMPOSITE='false' 
B_DEFAULT_NATIVE_DRIVER='false'
B_DISTRO_FLAG='false'
B_DISPLAY_DEVICES='false'
B_EXPERIMENTAL='false'
B_EXTRA_EXPERIMENTAL='false'
B_FGLRX_DEB_BUILDER='false'
B_FGLRX_DIRECT='true' # raising the white flag of surrender...
B_FORCE_OPTION='false'
B_FORCE_NO_COMPOSITE='false'
B_FORCE_UPDATE='false'
B_GET_LIVE_DRIVERS='false'
B_GUI_MODE='false'
B_IS_APTOSID_KERNEL='false'
B_IS_XEN='false'
B_KERNEL_MODULE_ONLY='false'
B_LOGGING_STARTED='false'
B_MOVE_X_CONF='false'
B_NATIVE_DRIVER='false'
B_NO_XVMC='false'
B_PRINT_VER='false' # utilities for smxi
B_REMOVE_MODELINES='false'
# B_RENDER_ACCEL='true' # default use, true
B_SKIP_AUTOSTART='false' # deprecated, not used
B_SKIP_CONFIG='false'
B_SKIP_CONNECT='false' # deprecated, not used
B_SKIP_INSTALL='false'
B_SKIP_RESTART='false'
B_SKIP_WGET='false'
B_SKIP_X_QUESTION='false'
B_SKIP_X_TEST='false'
B_SM_INSTALL='false' # utilities for smxi
B_TRIPLE_BUFFER='false'
B_TWINVIEW='false' # deprecated, commented out use
B_UPDATED='false'
B_USE_BETA='false' 
B_USE_DIRECT_KERNEL_HEADER='false' # deprecated, commented out use
B_USE_DISTRO_DRIVER='false'
B_USE_XVMC='false'
B_XORG_BACKED_UP='false'

## debugger/testing boolean switches
B_SKIP_FUNCTION='false'
B_TESTING_1='false' # triggers testing function
B_TESTING_2='false' # triggers post driver extract/patch exit
B_TESTING_3='false' # overrides testing cases xorg/kernel for driver support
B_TESTING_4='false' # triggers advanced general development testing cases
B_TESTING_5='false' # overrides patch tests
B_TESTING_6='false' # triggers new distro development tests

# kernel variables strings are now evaluated in kernel_string_info().
INSTALL_TO_KERNEL=''
KERNEL_ARCH=''
KERNEL_BASE='' # like: 2.6
KERNEL_THIRD='' # like: 19, for math use
# note the extra cut -d '-' -f 1 test is to dump the doubled 2.6.24 in new kernel strings.
KERNEL_THREE='' # like: 2.6.19
KERNEL_VERSION='' # full kernel name

# check for 64 bit first
if [ -n "$( uname -m | grep -o 'x86_64' )" ];then
	BITS="64"
else
	BITS="32"
fi

# this handles the 1.x syntax used by newer xorg versions
# it also handles the change in ID text they did with 1.4
# slicing out parts prior to parentheses: X.Org X Server 1.7.7
X_VERSION=$( X -version 2>&1 | grep 'X Window System' | cut -d '(' -f 1 | grep -Eo '[127]\.[0-9]' )
if [ -z "$X_VERSION" ];then
	X_VERSION=$( X -version 2>&1 | grep 'X.Org X Server' | cut -d '(' -f 1 | grep -Eo '[127]\.[0-9]' )
fi
CC=''
GL=''
# specific card types
FGLRX='fglrx'
INTEL='intel'
NEOMAGIC='neomagic'
NVIDIA='nvidia'
TDFX='tdfx'

# this path only exists on debian type distros I believe, but this will be null for others
DISPLAY_MANAGER=$( cat /etc/X11/default-display-manager 2>/dev/null )
DISPLAY_MANAGER=$( basename "$DISPLAY_MANAGER" 2>/dev/null )

# Position matters: 1-latest; 2-middle; 3-older; 4-oldest
VERSIONS=''
OTHER_VERSIONS=''
# other stuff: nothing now: these legacies are prerelease status for now
NV_VERSIONS='260.19.12:173.14.28:96.43.18:71.86.14'
NV_DEFAULT=$( echo $NV_VERSIONS | cut -d ':' -f 1 ) # >= 6xxx
NV_LEGACY_1=$( echo $NV_VERSIONS | cut -d ':' -f 4 ) # old, tnt etc
NV_LEGACY_2=$( echo $NV_VERSIONS | cut -d ':' -f 3 ) # ge4xx cards
NV_LEGACY_3=$( echo $NV_VERSIONS | cut -d ':' -f 2 ) # 5xxx cards

## beta drivers 
# use null for position (ie, ::) if no newer beta is availablet than current stable
NV_VERSIONS_BETA=':::'
NV_DEFAULT_BETA=$( echo $NV_VERSIONS_BETA | cut -d ':' -f 1 ) # >= 6xxx
NV_LEGACY_BETA_1=$( echo $NV_VERSIONS_BETA | cut -d ':' -f 4 ) # old, tnt etc
NV_LEGACY_BETA_2=$( echo $NV_VERSIONS_BETA | cut -d ':' -f 3 ) # ge4xx cards
NV_LEGACY_BETA_3=$( echo $NV_VERSIONS_BETA | cut -d ':' -f 2 ) # 5xxx cards

# latest quad: http://www.nvidia.com/object/linux_display_archive.html
NV_QUAD=$NV_DEFAULT # no more individual quad drivers
# this is what gets tested, and any other beta drivers remaining
NV_TESTING="$NV_VERSIONS_BETA:260.19.06"
# stable primary: 260.19.12
# stable primary: 256.35 256.44 256.53 
# stable primary: 195.36.08 ( bad, recalled ) 195.36.15 195.36.24 195.36.31
# stable primary: 190.42 190.53 
# stable primary: 185.18.14 185.18.29 185.18.31 185.18.36 
# stable primary: 180.44 180.51 180.60 
# stable legacy 1: 71.86.06 71.86.09 71.86.11 71.86.13 71.86.14
# stable legacy 2: 96.43.11 96.43.13 96.43.14 96.43.16 96.43.18 
# stable legacy 3: 173.14.12 173.14.18 173.14.20 173.14.22 173.14.25 173.14.27 
NV_OTHERS='256.35:195.36.31:195.36.24:195.36.15:190.53:190.42:185.18.36:180.60:177.82:173.14.25:173.14.22:169.12:100.14.19:96.43.17:96.43.16:96.43.14:71.86.13:71.86.11:71.86.09'

# distro legacies (default to Debian packages):
NV_DEBIAN_LEGACY_1='71xx'
NV_DEBIAN_LEGACY_2='96xx'
NV_DEBIAN_LEGACY_3='173xx'
# arch linux
NV_AR_CURRENT=''
NV_AR_LEGACY_3='173xx'
NV_AR_LEGACY_2='96xx'
# ubuntu 
NV_UB_CURRENT='185'
NV_UB_LEGACY_3='173'
NV_UB_LEGACY_2='96'
# fedora
NV_FED_CURRENT="-$NV_DEFAULT" # note this will be out of sync until repo catches up, needs tests
NV_FED_LEGACY_2='-96xx'
NV_FED_LEGACY_3='-173xx'
# set dynamically in fixes, line 529 or so
NVIDIA_DOWNLOAD_SITE='' 
# needs dynamic assignment because new drivers won't use this in the string
NV_PKG_NO=''
NV_64_ARCH='' # if nvidia changes file name use this

# other options: nothing now
# IMPORTANT: on function set_download_info the actual path file name is set:
FG_VERSIONS='10-10:10-9:9-3'
FG_DEFAULT='10-10'
FG_LEGACY='' # no legacy for ati + xorg >= 7.1
FG_TESTING=''
FG_OTHERS='10-9:10-8:10-7:10-6:10-5:10-4:10-3:10-2:10-1:9-12:9-11:9-10:9-9:9-8:9-7:9-6:9-5:9-4:9.2:9-1:8-12:8-11:8-10:8-9:8-8:8-7:8-6:8-5:8-4'
# set to sid/lenny/etch
FG_DISTRIB_ID=''
FG_DISTRIB_CODENAME=''
DRIVER_INSTALL=''
DRIVER_DEFAULT=''
DRIVER_OVERRIDE=''
DRIVER_QUAD=''
DRIVER_TESTING=''
# 0 - unsupported completely by any non-free driver
# 1 - nvidia oldest card versions supported / fglrx < x2000 cards
# 2 - nvidia midrange legacy card versions supported
# 3 - nvidia 5xxx cards only
# 100 - fully supported with latest driver
LEGACY_LEVEL=''
DRIVER_FILE=''

# here we're cutting out both card type and version number for cases with > 1 card
CARD_COUNT=$( lspci -n | grep -c '0300' )
#CARD_DATA=$( lspci -n | grep 0300 | cut -d ':' -f 3-4  | cut -d ' ' -f2 )
CARD_DATA=$( lspci -n | grep '0300' | grep -Eio '[a-f0-9]{4}:[a-f0-9]{4}' )
CARD_NUMBER=''
CARD_BRAND=''
# this is reset for multiple gfx cards in select_card()
# " around CARD_DATA is mandatory for avoiding new grep issue
BUS_ID=$( lspci -n | grep "$CARD_DATA" | grep -Eio '^[0-9]{1,2}:[0-9a-z]{1,2}(\.|:)[0-9]' | sed 's/\./:/')

# system paths
EAA='/etc/apt/apt.conf'
EAS='/etc/apt/sources.list'
EXXC='/etc/X11/xorg.conf'
EAR='/etc/arch-release'
EDV='/etc/debian_version'
EFR='/etc/fedora-release'
ELR='/etc/lsb-release'
GRUB1='/boot/grub/menu.lst'
GRUB1_FED='/boot/grub/grub.conf'
GRUB2='/boot/grub/grub.cfg'
GRUBED='/etc/default/grub'
KERNEL_HEADER_DIRECT='/usr/include/linux/kernel.h'
USRS='/usr/src/' 

INSTALL_DIRECTORY=''
FG_WORKING_DIR='fglrx-install'
# file and patch urls
NV_LIVE_DRIVERS='http://people.freedesktop.org/~aplattner/nvidia-versions'
PATCH_DOWNLOAD='http://smxi.org/sg/'
SCRIPT_DOWNLOAD='http://smxi.org/sg/'
SCRIPT_DOWNLOAD_DATA='http://smxi.org/sg/data/'
SCRIPT_DOWNLOAD_VERSION='http://smxi.org/sm/sm-versions'
SCRIPT_DOWNLOAD_DEV='http://techpatterns.com/downloads/distro/'
SCRIPT_DOWNLOAD_BRANCH_1='http://sgfxi.googlecode.com/svn/branches/one/'
SCRIPT_DOWNLOAD_BRANCH_2='http://sgfxi.googlecode.com/svn/branches/two/'

ARCH_FGLRX='arch-fglrx'
ARCH_NVIDIA='arch-nvidia'
DEBIAN_FGLRX='debian-fglrx'
DEBIAN_NVIDIA='debian-nvidia'
DISTRO_FGLRX=''
DISTRO_NVIDIA=''
FEDORA_FGLRX='fedora-fglrx'
FEDORA_NVIDIA='fedora-nvidia'
UBUNTU_FGLRX='ubuntu-fglrx'
UBUNTU_NVIDIA='ubuntu-nvidia'

LOG_FILE_DIR="/var/log/$SCRIPT_NAME/"
LOG_FILE="$SCRIPT_NAME.log"
LOGPS='log_function_data ps $FUNCNAME "$( echo $@ )"'
LOGPE='log_function_data pe $FUNCNAME'
LOGUS='log_function_data us $FUNCNAME "$( echo $@ )"'
LOGUE='log_function_data ue $FUNCNAME'

SCRIPT_ROTATE="/etc/logrotate.d/$SCRIPT_NAME"
SM_VALUES="/usr/local/bin/$SCRIPT_NAME-values"

EXPERIMENTAL_XORG_ATI='xserver-xorg-video-ati_6.6.193-1'
EXPERIMENTAL_LIBDRM2='libdrm2_2.4.0~git20070625-1'
EXPERIMENTAL_LIBDRM_DEV='libdrm-dev_2.4.0~git20070625-1'

# this handles two cases: 1 where user logged in directly as 'root', and
# 2, where user su to root.
LOGIN_PID=$( ps | grep ' login' )
if [ "$LOGIN_PID" == '' ];then
	LOGIN_PID=$( ps | grep ' su' )
fi
LOGIN_PID=$( awk '{print $1}' <<< $LOGIN_PID | grep -Eo "^[0-9]+$" )

# do some distro specific tweaks here too. Don't do this if
# distro maintainers have set package defaults above.
if [ -f "$EAR" -a "$B_ALLOW_AUTO_UPDATE" == 'true' ];then
	SCRIPT_HOME='/usr/bin'
fi

# allow user set globals to override script globals
if [ -f $SM_VALUES ];then
	source $SM_VALUES
fi

########################################################################
#### FUNCTIONS: UTILITY TOOLS
########################################################################

### -------------------------------------------------------------------
### driver+kernel support tests, and patch handlers:
### -------------------------------------------------------------------

## these are first to make it easy to update each new driver release support data

# args: $1- test type
driver_support_tests()
{
	eval $LOGUS
	# test for binary only tests here
	case $1 in
		supported-driver)
			case $CARD in
				$FGLRX)
					# xorg info: http://www.x.org/wiki/Releases/7.4
					# first dump if legacy level 1 and pre 9-4
					if [ "$LEGACY_LEVEL" -eq 1 -a "$B_USE_DISTRO_DRIVER" != 'true' ];then
						case $DRIVER_DEFAULT in
							8-*|9-1|9.2|9-3)
								: # these drivers are fine
								;;
							*)
								if [ "$B_TESTING_3" != 'true' ];then
									error_handler 221
								fi
								;;
						esac
					fi
					# test for >= xorg 1.6 support, using a whitelist of current drivers
					# drivers for now until old driver support is dropped, then change to
					# blacklist
					case $X_VERSION in
						1.9)
							case $DRIVER_DEFAULT in
								10-1[0-2]|11-*|12-*) # update when 1.9 is actually supported
									: # all other drivers fail to support xorg >= 1.9
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 226
									fi
									;;
							esac
							;;
						1.8|7.6)
							case $DRIVER_DEFAULT in
								10-[7-9]|10-1[0-2]|11-*|12-*) # update when 1.8 is actually supported
									: # all other drivers fail to support xorg >= 1.8
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 226
									fi
									;;
							esac
							;;
						1.7|7.5)
							case $DRIVER_DEFAULT in
								10-[4-9]|10-1[0-2]|11-*|12-*)
									: # all other drivers fail to support xorg >= 1.7
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 226
									fi
									;;
							esac
							;;
						1.6|7.[3-4])
							case $DRIVER_DEFAULT in
								9-[4-9]|9-1[0-2]|10-*|11-*|12-*)
									: # all other drivers fail to support xorg >= 1.6
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 226
									fi
									;;
							esac
							;;
					esac
					# handle no aptosid kernel support first for < 2.6.32
					# fglrx is working on all Debian/Liquorix kernels
					# for testing/debugging set this re:
					# http://techpatterns.com/docs/sgfxi-set-test-data.htm
					case $KERNEL_THIRD in
						2[5-9]|3[0-1])
							if [ "$B_IS_APTOSID_KERNEL" == 'true' ];then
								error_handler 229
							fi
							;;
					esac

					# handle libdrm > 2.3 version errors first
					case $DRIVER_DEFAULT in
						8-[4-9]|8-1[0-2]|9-1|9.2|9-[3-5])
							misc_fixes 'drm-2-x-test'
							;;
					esac
					# now the main support tests...
					case $KERNEL_THIRD in
						26)
							case $DRIVER_DEFAULT in
								8-4|8-5)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 234 $KERNEL_THIRD
									fi
									;;
							esac
							;;
						27)
							case $DRIVER_DEFAULT in
								8-4|8-5|8-6|8-7|8-8|8-9)
									if [ "$B_TESTING_" != 'true' ];then
										error_handler 234 $KERNEL_THIRD
									fi
									;;
								*)
									: 
									;;
							esac
							;;
						28)
							case $DRIVER_DEFAULT in
								8-4|8-5|8-6|8-7|8-8|8-9)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 234 $KERNEL_THIRD
									fi
									;;
								*)
									: 
									;;
							esac
							;;
						29)
							case $DRIVER_DEFAULT in
								9.2|9-[3-9]|9-1[0-2]|10-*|11-*)
									: 
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 234 $KERNEL_THIRD
									fi
									;;
							esac
							;;
						30)
							case $DRIVER_DEFAULT in
								9-8|9-9|9-1[0-2]|10-*|11-*)
									: 
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 234 $KERNEL_THIRD
									fi
									;;
							esac
							;;
						31|32)
							case $DRIVER_DEFAULT in
								9-1[0-2]|10-*|11-*)
									: 
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 234 $KERNEL_THIRD
									fi
									;;
							esac
							;;
						33)
							case $DRIVER_DEFAULT in
								10-[2-9]|10-1[0-2]|11-*)
									:
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 234 $KERNEL_THIRD
									fi
									;;
							esac
							;;
						34)
							case $DRIVER_DEFAULT in
								10-[5-9]|10-1[0-2]|11-*)
									:
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 234 $KERNEL_THIRD
									fi
									;;
							esac
							;;
						35)
							case $DRIVER_DEFAULT in
								10-[8-9]|10-1[0-2]|11-*)
									:
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 234 $KERNEL_THIRD
									fi
									;;
							esac
							;;
						36)
							case $DRIVER_DEFAULT in
								# note: unknown if -11 will support 36, -10 doesn't, assume -12 will
								# patch from Arch works in application, don't know if it really works
								10-1[0-2]|11-*) 
									:
									;;
								*)
									if [ "$B_TESTING_3" != 'true' ];then
										error_handler 234 $KERNEL_THIRD
									fi
									;;
							esac
							;;
						3[7-9])
							if [ "$B_TESTING_3" != 'true' ];then
								error_handler 234 $KERNEL_THIRD
							fi
							;;
					esac
					;;
				$NVIDIA)
# 					if [ "$DRIVER_DEFAULT" == "$DISTRO_NVIDIA" -a "$SYSTEM_CODENAME" == 'testing' ];then
# 						print_information_continue 'standard' "Your system appears to be Debian Testing based.\nThe $DISTRO_NVIDIA driver cannot build on Debian Testing because of a missing package.\nIf your system is Sid based, continue, otherwise exit now."
# 					else
						# test for >= xorg 1.5 support, using a blacklist now of previous
						# drivers rather than whitelisting
						# xorg info: http://www.x.org/wiki/Releases/7.4
						case $X_VERSION in
							1.[5-9]|2.[0-9]|7.[4-9])
								case $DRIVER_DEFAULT in
									169.12|100.14.19)
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 226
										fi
										;;
									# 180.*|177.*|173.14.15|96.43.09|71.86.07
									*)
										: ## support should be working, see feedback
										;;
								esac
								;;
						esac
						# note: the legacy 1 latest should handle xorg 1.7
						case $X_VERSION in
							1.9)
								case $DRIVER_DEFAULT in
									# not positive about 256 series + 1.9, or 96
									260.*|256.*|173.14.2[89]|96.43.1[9]|$DISTRO_NVIDIA)
										: # all other drivers fail to support xorg >= 1.9
										;;
									*)
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 226
										fi
										;;
								esac
								;;
							1.8)
								case $DRIVER_DEFAULT in
									260.*|256.*|195.36.[2-9][0-9]|173.14.2[789]|96.43.1[89]|$DISTRO_NVIDIA)
										: # all other drivers fail to support xorg >= 1.8
										;;
									*)
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 226
										fi
										;;
								esac
								;;
							1.7|7.[5])
								case $DRIVER_DEFAULT in
									260.*|256.*|195.*|190.53|173.14.2*|96.43.1*|71.86.1[34]|$DISTRO_NVIDIA)
										: # all other drivers fail to support xorg >= 1.7
										;;
									*)
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 226
										fi
										;;
								esac
								;;
							1.6|7.[3-4])
# 							1.[6-9]|2.[0-9]|7.[4-9])
								case $DRIVER_DEFAULT in
									71.86.11|71.86.09)
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 226
										fi
										;;
									*)
										: ## support should be working, see feedback
										;;
								esac
								;;
						esac
						
						# white list of known http downloads, otherwise use ftp, this will be required
						# for any future drivers auto detected beta drivers anyway.
						# driver=71.86.13;wget --spider http://download.nvidia.com/XFree86/Linux-x86/$driver/NVIDIA-Linux-x86-$driver-pkg0.run 
						# default download site for nvidia, return http://us.download if problems
						case $DRIVER_DEFAULT in
							190.53|190.42|185.18.36|180.60|177.82|173.14.2[25]|169.12|100.14.19|96.43.1[46]|71.86.1[134]|71.86.09)
								NVIDIA_DOWNLOAD_SITE='http://download.nvidia.com'
								;;
							*)
								NVIDIA_DOWNLOAD_SITE='ftp://download.nvidia.com'
								;;
						esac
						# ftp://download.nvidia.com/XFree86/Linux-x86/256.35/NVIDIA-Linux-x86-256.35.run
						#ftp://download.nvidia.com/XFree86/Linux-x86_64/256.35/NVIDIA-Linux-x86_64-256.35.run
						#ftp://download.nvidia.com/XFree86/Linux-x86_64/256.35/NVIDIA-Linux-x86-256.35.run
						# white list of old path version drivers
						# new download urls, no -pkgx in file name string
						case $DRIVER_DEFAULT in
							# old download urls, with -pkgx in file name string
							195.36.*|190.*|185.18.*|180.60|177.82|173.14.*|169.12|100.14.19|96.43.*|71.86.*)
								# this tweak thanks to ajw1980, who pointed out that pkg2 installs
								# 32 bit compatibility libs in 64 bit without further fuss.
								if [ "$BITS" == '64' ];then
									NV_PKG_NO='-pkg2'
								else
									NV_PKG_NO='-pkg0'
								fi
								;;
						esac
						# handle change to legacy 5xxx level cards
						case $DRIVER_DEFAULT in
							173.*.*|169.12|100.*.*|96.*.*|71.*.*|$DISTRO_NVIDIA)
								:
								;;
							# 180.11|180.08|180.06|177.82|177.80
							*)
								if [ "$LEGACY_LEVEL" -eq 3 ];then
									error_handler 227
								fi
								;;
						esac
						# basic version handling and support tests, unless otherwise reported,
						# $DISTRO_NVIDIA will be supported by default
						case $KERNEL_THIRD in
							24) # going to try just 2.6.24 links, see if any issues appear
								# this doesn't work on debian kernels
								if [ "$B_IS_APTOSID_KERNEL" == 'true' ];then
									misc_fixes nvidia-24-link # this might always be needed, all cases?
								fi
								;;
							26)
								case $DRIVER_DEFAULT in
									260.*|256.*|195.*|190.*|185.*|180.*|177.*|173.*.*|100.*.*|96.*.*|71.*.*|$DISTRO_NVIDIA)
										: # do nothing
										;;
									*)
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 234 $KERNEL_THIRD
										fi
										;;
								esac
								;;
							27)
								case $DRIVER_DEFAULT in
									260.*|256.*|195.*|190.*|185.*|180.*|177.*|173.*.*|100.*.*|96.*.*|71.*.*|$DISTRO_NVIDIA)
										: # do nothing
										;;
									*)
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 234 $KERNEL_THIRD
										fi
										;;
								esac
								;;
							28)
								case $DRIVER_DEFAULT in
									260.*|256.*|195.*|190.*|185.*|180.*|177.*|173.14.2*|96.43.1*|71.86.1*|71.86.09|$DISTRO_NVIDIA)
										: # do nothing
										;;
									*)
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 234 $KERNEL_THIRD
										fi
										;;
								esac
								;;
							29)
								case $DRIVER_DEFAULT in
									260.*|256.*|195.*|190.*|185.*|180.*|177.*|173.14.2*|96.43.1*|71.86.1*|71.86.09|$DISTRO_NVIDIA)
										: # do nothing
										;;
									*) # use 225 for beta testing errors
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 234 $KERNEL_THIRD
										fi
										;;
								esac
								;;
							30)
								case $DRIVER_DEFAULT in
									260.*|256.*|195.*|190.*|185.*|173.14.2*|96.43.1*|71.86.1*|71.86.09|$DISTRO_NVIDIA)
										: # do nothing
										;;
									*) # use 225 for beta testing errors
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 234 $KERNEL_THIRD
										fi
										;;
								esac
								;;
							# note: 34 not fully confirmed yet for all drivers/legacy levels
							31|32|33|34)
								case $DRIVER_DEFAULT in
									260.*|256.*|195.*|190.*|185.*|173.14.2*|96.43.1*|71.86.1*|$DISTRO_NVIDIA)
										: # do nothing
										;;
									*) # use 225 for beta testing errors
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 234 $KERNEL_THIRD
										fi
										;;
								esac
								;;
							35|36)
								# we'll assume the older drivers don't work here
								case $DRIVER_DEFAULT in
									260.*|256.*|173.14.2*|96.43.1*|71.86.1*|$DISTRO_NVIDIA)
										: # do nothing
										;;
									*) # use 225 for beta testing errors
										if [ "$B_TESTING_3" != 'true' ];then
											error_handler 234 $KERNEL_THIRD
										fi
										;;
								esac
								;;
						esac
# 					fi
					;;
			esac
			;;
		nvidia-supported-driver)
			:
			;;
		ati-supported-driver)
			:
			;;
	esac
	eval $LOGUE
}

# these patch calls used to be in lib files but this is cleaner/simpler long term
run_driver_patches()
{
	eval $LOGPS
	local patchFile=''

	case $CARD in
		$NVIDIA)
			case $KERNEL_THIRD in
				25)
					apply_module_patch pre
					case $DRIVER_DEFAULT in
						169.12)
							patchFile='NVIDIA_kernel-169.12-2286310.diff'
							apply_patch_file $patchFile
							;;
						# patch url: http://www.nvnews.net/vbulletin/showthread.php?t=112452
						100.14.19)
							# patch source url:
							# http://www.nvnews.net/vbulletin/showthread.php?t=112452&highlight=2.6.26
							# patch author: NiLuJe
							if [ "$BITS" == '32' ];then
								patchFile='NVIDIA-x86-100.14.19-kernel-2.6.25-compat.diff'
							else
								patchFile='NVIDIA-x86_64-100.14.19-kernel-2.6.25-compat.diff'
							fi
							apply_patch_file $patchFile
							;;
						96.43.05)
							patchFile='NVIDIA_kernel-96.43.05-2290218.diff'
							apply_patch_file $patchFile
							;;
					esac
					;;
				26)
					apply_module_patch pre

					case $DRIVER_DEFAULT in
						173.14.05)
							patchFile='NVIDIA_kernel-173.14.05-2419292.diff'
							apply_patch_file $patchFile
							;;
						100.14.19)
							# patch source url:
							# http://www.nvnews.net/vbulletin/showthread.php?t=112452&highlight=2.6.26
							# patch author: NiLuJe, MamiyaOtaru, zander (from nvidia)
							# patchFile='NVIDIA-100.14.19-kernel-2.6.25+26-compat.diff'
							patchFile='NVIDIA-100.14.19-for-2.6.26.patch'
							apply_patch_file $patchFile
							;;
					esac
					;;
				27)
					apply_module_patch pre
					case $DRIVER_DEFAULT in
						177.13)
							# patch author: zander, nvidia; patch src:
							# http://www.nvnews.net/vbulletin/showthread.php?t=117209
							# patch url:
							# http://www.nvnews.net/vbulletin/attachment.php?attachmentid=32559&d=1218212371
							patchFile='NVIDIA_kernel-177.13-2627763.diff'
							apply_patch_file $patchFile
							;;
						# patch url: http://www.nvnews.net/vbulletin/showthread.php?t=112452
						100.14.19)
							patchFile='NVIDIA-100.14.19-kernel-2.6.27-compat.patch'
							apply_patch_file $patchFile
							;;
					esac
					;;
				28)
					case $DRIVER_DEFAULT in
						177.80)
							# post 21:http://www.nvnews.net/vbulletin/showthread.php?t=121790
							patchFile='NVIDIA_2.6.28-177.80-2990799.diff'
							apply_patch_file $patchFile
							;;
						177.82)
							# post 44: http://www.nvnews.net/vbulletin/showthread.php?t=121790&page=2
							patchFile='NVIDIA_2.6.28-177.82.diff'
							apply_patch_file $patchFile
							;;
					esac
					;;
				30)
					case $DRIVER_DEFAULT in
						71.86.09)
							# post 1:  http://www.nvnews.net/vbulletin/showthread.php?t=133990
							# alt: http://www.nvnews.net/vbulletin/showthread.php?p=1984486
							patchFile='NVIDIA_96.43.11-2.6.30.diff'
							apply_patch_file $patchFile
							;;
						185.18.*)
							#http://www.nvnews.net/vbulletin/showthread.php?t=133112
							patchFile='NVIDIA-185.18.14-2.6.30.diff'
							apply_patch_file $patchFile
							;;
					esac
					;;
				31)
					case $DRIVER_DEFAULT in
						185.18.*)
							#http://www.nvnews.net/vbulletin/showthread.php?t=133112
							patchFile='NVIDIA-185.18.14-2.6.30.diff'
							apply_patch_file $patchFile
							;;
					esac
					;;
				32|33)
					# test if the /generated directory exists, if it does, then use patch.
					if [ -n "$( misc_fixes linux-generated-patch )" -o "$B_TESTING_4" == 'true' ];then
						case $DRIVER_DEFAULT in
							# this is fixed in newest beta, it does auto testing for /generated/
							195.30)
								# http://www.nvnews.net/vbulletin/showthread.php?t=142794&page=2#20
								patchFile='NVIDIA-195-2.6.33.diff'
								apply_patch_file $patchFile
								;;
							190.53) # won't be needed for new version, it will be fixed
								# http://www.nvnews.net/vbulletin/showthread.php?t=142794&page=2#20
								patchFile='NVIDIA-190.53-2.6.33.diff'
								apply_patch_file $patchFile
								;;
						esac
					fi
					;;
			esac
			;;
		$FGLRX)
			case $KERNEL_THIRD in
				25|26)
					case $DRIVER_DEFAULT in
# 						8-4|8-5)
# 							# debian kernls work normally, no patch required
# 							# note: due to concerns raised, this patch is not going to be used
# 							if [ "$B_IS_APTOSID_KERNEL" == 'true' ]
# 							then
# 								# pre patch link required, just to keep the information for future reference:
# 								ln -s arch/x86/usr/X11R6/lib/libfglrx_gamma.so.1.0 arch/x86/usr/X11R6/lib/libfglrx_gamma.so.1
# 								ln -s arch/x86_64/usr/X11R6/lib64/libfglrx_gamma.so.1.0 arch/x86_64/usr/X11R6/lib64/libfglrx_gamma.so.1
# 								patchFile=''
# 								#apply_patch_file $patchFile
# 							fi
# 							;;
						8-6)
							patchFile='0001-catalyst-8.6-linux-2.6.26.patch'
							apply_patch_file $patchFile
							patchFile='0002-catalyst-8.6-linux-2.6.26.patch'
							apply_patch_file $patchFile
							patchFile='0003-catalyst-8.6-linux-2.6.26.patch'
							apply_patch_file $patchFile
							;;
						8-7)
							# patch url: http://bugs.gentoo.org/attachment.cgi?id=161335
							# found at: http://bugs.gentoo.org/show_bug.cgi?id=232609
							patchFile='FGLRX-8.7-2.6.26.patch'
							# this one is crap, bad hunks
							#patchFile='FGLRX-0004-Linux-2.6.26.x-kernels-support.patch'
							apply_patch_file $patchFile
							;;
					esac
					;;
				29)
					case $DRIVER_DEFAULT in
						9.2|9-3|9-4|9-5|9-6|9-7)
							# src: http://www.phoronix.com/forums/showthread.php?t=15165
							patchFile='FGLRX-2.6.29-9.2-5.diff'
							apply_patch_file $patchFile
							:
							;;
					esac
					;;
				30)
					case $DRIVER_DEFAULT in
						9-6)
							if [ "$B_TESTING_3" == 'true' ];then
								patchFile='FGLRX-2.6.30-9-6.diff'
								apply_patch_file $patchFile
							fi
							;;
						esac
					;;
				32)
					case $DRIVER_DEFAULT in
						9-11|9-12)
							patchFile='FGLRX-2.6.32-9-11.diff'
							apply_patch_file $patchFile
							;;
					esac
					;;
				33)
					# these handle that /generated/ path change in kernel headers
					# test if the /generated directory exists, if it does, then use patch.
					if [ -n "$( misc_fixes linux-generated-patch )" -o "$B_TESTING_4" == 'true' ];then
						case $DRIVER_DEFAULT in
							10-2)
								patchFile='FGLRX-2.6.33-10-2.diff'
								apply_patch_file $patchFile
								;;
							10-[3-5])
								patchFile='FGLRX-2.6.33-10-x.diff'
								apply_patch_file $patchFile
								;;
						esac
					fi
					;; 
				34)
					# these handle that /generated/ path change in kernel headers
					# test if the /generated directory exists, if it does, then use patch.
					if [ -n "$( misc_fixes linux-generated-patch )" -o "$B_TESTING_4" == 'true' ];then
						case $DRIVER_DEFAULT in
							10-[4-5])
								patchFile='FGLRX-2.6.33-10-x.diff'
								apply_patch_file $patchFile
								patchFile='FGLRX-2.6.34-rc4-10-4.diff'
								apply_patch_file $patchFile
								;;
							10-[6])
# 								patchFile='FGLRX-2.6.33-10-x.diff' # fails
# 								apply_patch_file $patchFile
								patchFile='FGLRX-2.6.34-rc4-10-4.diff' # works
								apply_patch_file $patchFile
								;;
						esac
					fi
					;; 
				36)
					case $DRIVER_DEFAULT in
						10-1[0-1]) # run this for -11 too maybe it will work
							patchFile='FGLRX-2.6.36-10-10.diff'
							apply_patch_file $patchFile
							patchFile='FGLRX-2.6.36-10-10-makefile-compat.diff'
							apply_patch_file $patchFile
							;;
					esac
					;;
			esac
			;;
	esac

	# this is for dev testing of patches or fixes
	if [ "$B_TESTING_4" == 'true' ];then
		: # doing nothing for now
	fi
	eval $LOGPE
}

### -------------------------------------------------------------------
### primary startup - test data, colors
### -------------------------------------------------------------------

# only for debugging purposes
set_test_data()
{
	local username=''

	if [ "$B_TESTING_1" == 'true' ];then # set testing directories etc
## NOTE: it's important to start all comments in here at first character for cleanup updater
#		# this is required for testing to make sure we always are starting with true
#		# latest script versions

# 		# note: devs: double check this output to make sure it's your user name
#		username=$( getent passwd 1000|cut -d \: -f1 )
#		SCRIPT_HOME="/home/$username/bin/scripts/sgfxi/dev/"
#		SCRIPT_WORKING_DIR="/home/$username/bin/scripts/sgfxi/dev"
#		LOG_FILE_DIR="/home/$username/bin/scripts/sgfxi/dev/"
# 		PATCH_DOWNLOAD='http://smxi.org/sg/'
#		cd $SCRIPT_HOME
#		rm -f $SCRIPT_NAME.log
# 		# sgfxi doesn't support any legacy ATI stuff
# 		CARD_DATA=1002:7280 # fake ati pre x2000 card
#		CARD_DATA=1002:9442 # fake ati post x2000 card
# 		CARD_DATA=10de:0020 # fake nvidia oldest legacy (7x.xx.xx drivers)
# 		CARD_DATA=10de:0280 # fake nvidia mid legacy (9x.xx.xx drivers)
# 		CARD_DATA=10de:0322 # fake nvidia 5xxx legacy (173.xx.xx drivers)
# 		CARD_DATA=10de:0422 # fake nvidia current card (GS 8400)
# 		FG_DEFAULT='8-5'
# 		NV_DEFAULT='177.80'
# 		# set system bits to test 32/64 specific behaviors
# 		BITS=64
# 		# if you want to test for/without aptosid kernels, set to null '' or 'true'
#		B_IS_APTOSID_KERNEL='false'
# 		# to test patches/error handling for a specific kernel major version,
# 		# ie: 2.6.25 here
#		KERNEL_THIRD=36
# 		# values: '' or 'true'
# 		B_IS_XEN='false'
# 		# check for specific system base tests, can be:
# 		# 'sid' 'testing' 'stable' 'etch'
#		SYSTEM_BASE='debian'
# 		SYSTEM_CODENAME='testing'
#		X_VERSION='1.7' # override for patching etc
# leave this at first character or errors in updater tools will occur
:
	fi
}

# set global color variables
# options: 0 - turns off all colors; 1 - defaults
set_script_colors()
{
	# set colors
	case $SCRIPT_COLORS in
		0)
			W='' # red: Warning message
			E='' # yellow: script Error
			S='' # green: Standard message
			Q='' # CYAN: Questions
			M='' # CYAN: Message
			B='' # BLUE: Message
			C='' # MAGENTA: Command or Path
			N='' # default system console color: Normal :: make last in colors
			;;
		1)
			W="[1;31m" # red: Warning message
			E="[1;33m" # yellow: script Error
			S="[1;32m" # green: Standard message
			Q="[1;36m" # CYAN: Questions
			M="[1;36m" # CYAN: Message
			B="[1;34m" # BLUE: Message
			C="[1;35m" # MAGENTA: Command or Path
			N="[0;39m" # default system console color: Normal :: make last in colors
			;;
		2)
			W="[1;31m" # red: Warning message
			E="[1;33m" # yellow: script Error
			S="[0;37m" # Standard message
			Q="[0;36m" # CYAN: Questions
			M="[1;36m" # CYAN: Message
			B="[0;37m" # BLUE: Message
			C="[1;35m" # MAGENTA: Command or Path
			N="[0;39m" # default system console color: Normal :: make last in colors
			;;
		3)
			W="[1;31m" # red: Warning message
			E="[1;35m" # magenta: script Error
			S="[0;33m" # brown
			Q="[1;34m" # light blue: Questions
			M="[0;36m" # cyan: Message
			B="[0;33m" # brown: Message
			C="[0;32m" # green: Command or Path
			N="[0;39m" # default system console color: Normal :: make last in colors
			;;
		4)
			W="[0;31m" # red: Warning message
			E="[0;33m" # brown: script Error
			S="[0;34m" # blue: Standard message
			Q="[1;30m" # dark gray: Questions
			M="[1;30m" # dark gray: Message
			B="[0;34m" # blue: Message
			C="[0;35m" # purple: Command or Path
			N="[0;39m" # default system console color: Normal :: make last in colors
			;;
	esac

	CALLER_DEF=${S} # will switch default output color to the calling script's
	S=${B} # this is slightly tricky, making standard blue AFTER the caller def is set.
	PLINE='- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'
	LINE="${S}$PLINE${N}"
	ELINE="${E}$PLINE${N}"
	MLINE="${M}$PLINE${N}"
	WLINE="${W}$PLINE${N}"
}

### -------------------------------------------------------------------
### Error handling
### -------------------------------------------------------------------
error_handler()
{
	local errorCode=$1 # error number
	local errorExtra=$2 # this is secondary info, like failed package name
	local errorData='' errorData2=''
	local ErrorMessage=''

	case $errorCode in
		# general system checks
		254)
			errorData="No supported $CARD card found!"
			;;
		253)
			errorData="No supported $CARD card found!\nYou can use this script to install the native Xorg drivers: $SCRIPT_NAME -n"
			;;
		252)
			errorData="This does not appear to be a Debian/Ubuntu/Arch based system! If you know that it is\nand received this error, please let the maintainer know and he'll try to correct the\ndistro identification failure. Post on the script forums: http://techpatterns.com/forums/forum-33.html\nwith your system information, including the contents of these files, if present:\n/etc/issue\n/etc/debian_version\n/etc/lsb-release"
			;;
		251)
			errorData="You must be logged in as root to run this script."
			;;
		250)
			errorData="You must be out of X/Desktop (like KDE, Gnome, Flux, LXDE etc) to run this feature."
			;;
		249)
			errorData="Your system does not have the correct version of X, $EXXC"
			;;
		248)
			errorData="Sorry, Ubuntu isn't supported by this script"
			;;
		247)
			errorData="You can't use the composite option with this driver: $DRIVER_DEFAULT"
			;;
		246)
			errorData="The driver: $DRIVER_DEFAULT is not currently supported for kernel version 2.6.$KERNEL_THIRD"
			;;
		245)
			errorData2=''
			if [ "$CARD" == "$FGLRX" -a "$B_FGLRX_DIRECT" != 'true' ];then
				errorData2="\nYou might want to try installing without the -D (formerly -F) option instead, which will do a\ndirect (no debs) binary install from the FGLRX run package.\nThis works more reliably for some systems (especially 64 bit)."
			fi
			errorData="The $CARD installer exited with the error: $errorExtra$errorData2\nA copy of this driver installer error log is also here: $LOG_FILE"
			;;
		244)
			errorData="Xorg does not appear to be installed."
			;;
		243)
			errorData="Your kernel type $KERNEL_BASE is not supported for these drivers."
			;;
		242)
			errorData="This script requires X.org 7.1 or greater to be installed on your system."
			;;
		241)
			errorData="This script does not support the $CARD driver: $errorExtra\nPlease make sure to enter a supported driver when using the -o option."
			;;
		240)
			errorData="This script does not support the $CARD driver: $errorExtra"
			;;
		239)
			errorData="This script does not support installing $CARD drivers in livemode."
			;;
		238)
			errorData="There does not appear to be a live connection, or $SCRIPT_NAME script server is down.\nIf you are sure you have a connection, restart script with -Z option to cancel connection test."
			;;
		237)
			errorData="The native xorg driver you selected: $errorExtra is not supported."
			;;
		236)
			errorData="An ATI $CARD error makes them not support your Xorg version $errorExtra\n If you are using less than R500 type card, you can install native radeon drivers with this script.\nUse this syntax to install those and reconfigure xorg.conf: $SCRIPT_NAME -N radeon"
			;;
		235)
			errorData="The driver $DRIVER_DEFAULT requires the 2.6.$errorExtra kernel to run.\nYou are running the $KERNEL_THREE kernel. Please update your kernel now."
			;;
		234)
			errorData="The driver $DRIVER_DEFAULT does not support the 2.6.$errorExtra kernel.\nYou are running the $KERNEL_VERSION kernel. Unable to install your $DRIVER_DEFAULT driver.\nYou can override this test with -! 6 option. If install works, let maintainer know."
			;;
		233) errorData="Creating the fix: $errorExtra for your $DRIVER_DEFAULT and kernel $KERNEL_VERSION failed."
			;;
		232)
			errorData="The kernel for -K option: $errorExtra does not appear to be installed in your system."
			;;
		231)
			errorData="The file: $errorExtra appears to be corrupted. Please try to update again."
			;;
		230)
			errorData="Could not detect gcc version: $errorExtra, or it is not installed.\nPlease let the script maintainer know, this may be a bug in the script."
			;;
		229)
			errorData="The driver: $DRIVER_DEFAULT does not work on aptosid/sidux kernels.\nYou are trying to install it to this kernel: $KERNEL_VERSION\nCurrently $FGLRX only works on new non-aptosid kernels."
			;;
		228)
			errorData="The option you selected: $errorExtra is not supported."
			;;
		227)
			errorData="The newest $CARD drivers ( >= 177.167 ) no longer support your $CARD GeForce 5xxx card.\nYou must use the $NV_LEGACY_3 driver or lower.\nThat is the default driver when you run this script."
			;;
		226)
			errorData="The driver you selected: $DRIVER_DEFAULT does not support your current Xorg version: $X_VERSION\nIf this is wrong, please let the script maintainer know.\nYou can override this test with -! 6 option. If install works, let maintainer know."
			;;
		# this is only for nvidia latest kernel + beta errors
		225)
			errorData="The driver $DRIVER_DEFAULT does not support the 2.6.$errorExtra kernel.\nYou are installing the driver to kernel: $KERNEL_VERSION\nPlease try the beta driver instead. Use this command to install beta drivers\nto either non-current kernel: $SCRIPT_NAME -cB -K $KERNEL_VERSION\nor to current kernel: $SCRIPT_NAME -cB"
			;;
		224)
			errorData="Your system is missing the required kernel header package: $errorExtra\n and it is not currently available in your repos. Cannot continue.\nPlease either update your kernel and kernel headers,\nor find and install kernel headers for $KERNEL_VERSION\nYou can override this test with -! 6 option. If install works, let maintainer know."
			;;
		223)
			errorData="The install of the missing deb from your $SM_KERNEL_DOWNLOADS directory:\n$extraData\nhas failed for unknown reasons. Sorry, we did our best."
			;;
		222)
			errorData="The Xorg driver $extraData you are trying to install is not available\nfor your version of $DISTRIB_ID: $DISTRIB_CODENAME"
			;;
		221)
			errorData="AMD/ATI had dropped fglrx non-free driver support for your card type as of driver release 9-4\nOnly cards x2000 or newer are now supported by AMD/ATI for this driver.\nIf you know your card is supported, please let the $SCRIPT_NAME maintainer know.\nYou can override this test with -! 6 option. If install works, let maintainer know."
			;;
		220)
			errorData="The Driver you are trying to install does not work with libdrm2 version 2.4.x less than 2.4.11.\nYour installed version of libdrm2 is: $errorExtra\n\nIf you are using Debian Sid, you must upgrade your libdrm2 to 2.4.11 or greater."
			;;
		219)
			errorData="Fglrx direct driver install method does not allow you to install the\ndriver to another kernel, using the -K option, sorry. You must be booted into\nthe kernel you are installing the driver to for this driver method to work."
			;;
		218)
			errorData="Something went wrong in the creation of your new $EXXC file\nPlease let the script maintainer know."
			;;
		217)
			errorData="No supported $CARD card found for the distro driver (-d - formerly -s) installer option!\nYou can use this script to install the native Xorg drivers: $SCRIPT_NAME -n"
			;;
		216)
			errorData="You are using Ubuntu but you do not appear to have the 'restricted' repos enabled.\nPlease enable them before continuing, thank you."
			;;
		215)
			errorData="Your new $EXXC is missing, or is not located where expected.\nPlease let the script maintainer know."
			;;
		214)
			errorData="Cannot create your new $EXXC because X cannot be killed.\nPlease let the script maintainer know."
			;;
		213)
			errorData="$SCRIPT_NAME cannot locate any /boot/grub/ config files. Unable to continue.\n$SCRIPT_NAME requires grub config files: /boot/grub/menu.lst or /boot/grub/grub.cfg\n$SCRIPT_NAME does not support lilo or unmounted /boot partitions.\nThe action: $errorExtra cannot be done without an active Grub on your system."
			;;
		# specific install issues
		200)
			errorData="The package: $errorExtra failed to install, please check apt for any problems."
			;;
		199) # replaced by 231
			errorData="The file: $errorExtra failed to download - wget reports success."
			;;
		198)
			errorData="The url/file: $errorExtra\nfailed to download - wget error."
			;;
		197)
			errorData="The graphics driver installer: $errorExtra failed to download - wget error."
			;;
		196)
			errorData="The driver package: $errorExtra failed to extract and has been deleted."
			;;
		195)
			errorData="dkpg -i failed for package: $errorExtra"
			;;
		194)
			errorData="m-a build failed for package: $errorExtra"
			;;
		193)
			errorData="m-a install failed for package: $errorExtra"
			;;
		192)
			errorData="The $CARD driver uninstaller exited with this error: $errorExtra"
			;;
		191)
			errorData="This script cannot proceed if you leave $errorExtra installed."
			;;
		190)
			errorData="Removing package $errorExtra failed."
			;;
		189)
			errorData="Downloading the experimental driver $errorExtra failed."
			;;
		188)
			errorData="The experimental driver $errorExtra package is empty."
			;;
		187)
			errorData="The experimental driver package $errorExtra is not available currently, sorry."
			;;
		186)
			errorData="The package $errorExtra was not created. Cannot continue with install."
			;;
		185)
			errorData="m-a prepare failed for package: $errorExtra"
			;;
		184)
			errorData="m-a update failed for package: $errorExtra"
			;;
		183)
			errorData="depmod -a failed for package: $errorExtra"
			;;
		182)
			errorData="m-a clean failed for package: $errorExtra"
			;;
		181)
			errorData="Patch file: $errorExtra failed to download."
			;;
		180)
			errorData="wget error: Patch file: $errorExtra failed to download."
			;;
		179)
			errorData="Patching error: file: $errorExtra failed."
			;;
		178)
			errorData="Unsupported testing option argument: -! $errorExtra"
			;;
		177)
			errorData="Used -z command but no X application is present in system."
			;;
		176)
			errorData="Whoops, how did this happen? It appears you are not running a supported Distro for distro driver install."
			;;
		175)
			errorData="You are using the -k (build kernel module only) option, but required file: $errorExtra\nis not found in $SCRIPT_WORKING_DIR\nNote: if your installed driver is NOT the default $SCRIPT_NAME offers, you have to\nuse either the -o <driver number> OR the -B option (if you are using current beta driver)\nplus the -! 40 option. EG: to install beta to all kernels: $SCRIPT_NAME -B -! 40"
			;;
		174)
			errorData="The -k option cannot be used if you are using distribution packaged nVidia drivers."
			;;
		173)
			errorData="The -k option only supports nVidia cards, sorry."
			;;
		172)
			errorData="The -k option can only be used to install to the same driver that is running.\nYour system is running $errorExtra but you are building the module for: $DRIVER_DEFAULT\nYou can use the -o <driver version> option to override the defaults."
			;;
		171)
			errorData="The kernel module build failed with error code: $errorExtra\nPlease check /var/log/nvidia-installer.log for more information about the failure.\nA copy of this nvidia error log is also here: $LOG_FILE\nPlease try to reinstall the driver using: sgfxi -f (force override module build)\nbecause sometimes modules cannot be built to new kernels without the source\nbeing patched first, which requires a driver reinstall."
			;;
		170)
			errorData="An nvidia module already exists for $KERNEL_VERSION at path:\n/lib/modules/$KERNEL_VERSION/kernel/drivers/video/nvidia.ko\nYou must either remove this manually, or install a new driver with $SCRIPT_NAME.\nInstalling a driver will remove all previous modules, then you can\nrebuild them with the -! 40 option (see $SCRIPT_NAME -h for more information on that method)."
			;;
		169)
			errorData="No previous $NVIDIA $SCRIPT_NAME run package install detected for -k option module build."
			;;
		168)
			errorData="An Xorg update overwrote $NVIDIA run package files. You must reinstall $NVIDIA driver.\nUnable to build -k option module."
			;;
		100)
			errorData="The function: $errorExtra exited through user action."
			;;
		*)
			errorData="Unexpected Error !"
			;;
	esac
	ErrorMessage="ERROR: ($errorCode) $errorData"
	echo -e ${E}$ErrorMessage${N}
	if [ -f $LOG_FILE -a "$B_LOGGING_STARTED" == 'true' ];then
		log_function_data "$ErrorMessage"
		echo
		echo "${S}Log file is located here: $LOG_FILE"
	fi
	echo "${M}Exiting script now.${N}"

	exit $errorCode
}

### -------------------------------------------------------------------
### card type/version detections
### -------------------------------------------------------------------

# this only runs if card count > 1
select_card()
{
#cardData=$(echo "00:0d.0 VGA compatible controller [0300]: nVidia Corporation GeForce 6100 nForce 405 [10de:03d1] (rev a2)
#02:00.0 VGA compatible controller [0300]: nVidia Corporation G71 [GeForce 7300 G S] [10de:01df] (rev a1)"  | grep -E 'VGA' | cut -d ':' -f 3-4 | cut -d ' ' -f 2-50 | tr ' ' '-' )
#tester="00:0d.0 0300: 10de:03d1 (rev a2)
#02:00.0 0300: 10de:01df (rev a1) "

	local cardData=$( lspci -nn | grep 'VGA' | cut -d ':' -f 3-4 | cut -d ' ' -f 2-50 | tr ' ' '-' )
	local cards='' card='' singleCardId=''
	local options='' opt='' bFound='false'
	local timeStampXorg=$EXXC-bu-$( date +%Y-%m-%d-%H:%M:%S )

	echo $MLINE
	echo "${S}The script detected more than one video card in your system:"
	echo "${C}$cardData"
	echo
	if [ "$B_SKIP_CONFIG" != 'true' ];then
		echo "${M}If you want to preserve your current ${C}xorg.conf${M}, for example if you use dual"
		echo "card setup, and your system is working fine with the driver you are installing,"
		echo "please restart ${C}$SCRIPT_NAME${M} with extra ${C}-C${M} option and it will not change xorg.conf."
		echo
		echo "${C}$SCRIPT_NAME${S} will adjust your xorg.conf busID. For typical, single monitor/dual card setups, this is desirable,"
		echo "but for rare cases of dual card, dual monitor setups, you may want to start with ${C}-C${S} (exit here to do so) "
		echo
		
		echo "If you proceed without ${C}-C${S}, a copy of your current ${C}xorg.conf${S} will be made here: ${C}$timeStampXorg"
	else
		echo "${S}Because you started with ${C}-C${S} option, ${C}$SCRIPT_NAME${S} will NOT change your ${C}xorg.conf${S} here"
		echo "but will simply set which card to use for the automatic driver selection. Just pick the card"
		echo "you want ${C}$SCRIPT_NAME${S} to use as the main card and ${C}$SCRIPT_NAME${S} will continue to installing the proper driver."
	fi
	echo
	echo "${S}Please select which card you want to install a driver for now to proceed:"
	echo $MLINE

	options="$cardData exit"
	select opt in $options
	do
		for card in $options
		do
			if [ "$opt" == "$card" ];then
				if [ "$card" == 'exit' ];then
					echo "${S}Exiting script now.${N}"
					exit 0
				else
					singleCardId=$( echo $card | grep -Eo -i '[a-z0-9]{4}:[a-z0-9]{4}' )
					echo "${S}You have elected to install drivers for this video card:"
					echo "${C}$card${N}"
					# override the global values and handle this explicitly
					# note that we need to do this whether or not -C is used
					CARD_DATA=$singleCardId

					if [ "$B_SKIP_CONFIG" != 'true' ];then
						if [ ! -e $timeStampXorg ];then
							cp $EXXC $timeStampXorg
						fi
						log_function_data "xorg.conf was backed up to: $timeStampXorg"
						B_XORG_BACKED_UP='true'
						# set correct bus id as last step, note you have to check for . in PCI string:
						# like this: O1:00.0 and change it to O1:00:0
						BUS_ID=$( lspci -n | grep "$CARD_DATA" | grep -Eio '^[0-9]{1,2}:[0-9a-z]{1,2}(\.|:)[0-9]' | sed 's/\./:/')

						# handle explicit assignment of busid to avoid errors
						echo "${S}Updating ${C}xorg.conf${S} to use the card with this BusID: ${C}$BUS_ID${N}"
						if [ -n "$BUS_ID" ];then
							# create a dummy in case it's needed by new xorg system
							create_section_device
							pcibusid_hex_to_dec # need to get rid of hex due to xorg error
							# this is redundant if set above but easier to do for all cases
							sed -i -r 's/\s*#*\s*BusID.*/\tBusID\t"PCI:'$BUS_ID'"/' $EXXC
						fi
					fi
				fi
				bFound='true'
				break
			else
				bFound='false'
			fi
		done
		break
	done
	if [ "$bFound" != "true" ];then
		echo "${E}Please select one of the numbers for your choices!${N}"
		select_card
	fi
}
#select_card;exit

# this is separated from detect card because it will be used for nv/ati basic card tests
set_card()
{
	local bCardFound='false' card=''

	# note: select_card has already handled multiple cards on box, so no need to loop it
	CARD_BRAND=$( echo $CARD_DATA | cut -d ':' -f1 )
	case $CARD_BRAND in
		10de|12d2)
			CARD=$NVIDIA
			bCardFound='true'
			B_DEFAULT_NATIVE_DRIVER='true'
			;;
		1002)
			CARD=$FGLRX
			bCardFound='true'
			B_DEFAULT_NATIVE_DRIVER='true'
			;;
		8086)
			CARD=$INTEL
			bCardFound='true'
			B_DEFAULT_NATIVE_DRIVER='true'
			;;
		10c8)
			CARD=$NEOMAGIC
			bCardFound='true'
			B_DEFAULT_NATIVE_DRIVER='true'
			;;
		121a)
			CARD=$TDFX
			bCardFound='true'
			B_DEFAULT_NATIVE_DRIVER='true'
			;;
		*)
			# this is required to handle unknown card types when forced override is used
			if [ -n "$NATIVE_OVERRIDE" ];then
				bCardFound='true'
			fi
			;;
	esac
	if [ "$bCardFound" != 'true' ];then
		error_handler 254
	fi
}
## card support information:
#  nvidia: http://us.download.nvidia.com/XFree86/Linux-x86/1.0-9755/README/appendix-a.html
## pick out the id string for nvidia/fglrx, set all the master variables for nv/fg
detect_card_version()
{
	local foundVersion='' version='' card='' cardBrand='' cardNumber=''
	local isQuad='' is8xxx=''

	# note: select_card has already handled multiple cards on box, so no need to loop it
	cardBrand=$( echo $CARD_DATA | cut -d ':' -f1 )
	cardNumber=$( echo $CARD_DATA | cut -d ':' -f2 )
	case $cardBrand in
		10de|12d2)
			# these will also assign dynamic betas to $NV_TESTING prior to sending it
			# to the master DRIVER_TESTING for support tests right after
			DRIVER_DEFAULT=$( assign_standard_or_beta_driver 'default' 'driver' )
			B_BETA_EXISTS=$( assign_standard_or_beta_driver 'default' 'set-exists' )
			DRIVER_TESTING=$NV_TESTING
			VERSIONS=$NV_VERSIONS
			OTHER_VERSIONS=$NV_OTHERS
			CARD_NUMBER=$cardNumber
			# do some card specific tests to determine generic classes
			isQuad=$( lspci | grep 'VGA' | grep -i -o 'quadro' )
			is8xxx=$( lspci | grep 'VGA' | grep -Eo '8[0-9]{3}' )
			case $cardNumber in
				# http://listing.driveragent.com/pci/10de/?q=94c3 # later series
				# http://listing.driveragent.com/pci/12d2/?q=94c3 # full legacy
				0008|0009|0010|0018|0019)
					error_handler 253 # if card in this list exit
					LEGACY_LEVEL=0
					;;
				0020|0028|0029|002c|002d|00a0|0100|0101|0103|0150|0151|0152|0153|0170)
					DRIVER_INSTALL=$( assign_standard_or_beta_driver 'legacy-1' 'driver' )
					B_BETA_EXISTS=$( assign_standard_or_beta_driver 'legacy-1' 'set-exists' )
					# B_RENDER_ACCEL='' # set default to false
					LEGACY_LEVEL=1
					# buntu doesn't have 71xxx drivers in package pool since they don't support
					# new xorg
					case $SYSTEM_BASE in
						ubuntu)
							if [ "$B_USE_DISTRO_DRIVER" == 'true' ];then
								error_handler 217 # if card in this list exit
							fi
							;;
					esac
					;;
				0110|0111|0112|0113|0170|0171|0172|0173|0174|0175|0176|0177|0178|0179|017a|017c|017d|0180|0181|0182|0183|0185|0186|0187|0188|018a|018b|018c|01a0|01f0|0200|0201|0202|0203|0250|0251|0253|0258|0259|025b|0280|0281|0282|0286|0288|0289|028c)
					DRIVER_INSTALL=$( assign_standard_or_beta_driver 'legacy-2' 'driver' )
					B_BETA_EXISTS=$( assign_standard_or_beta_driver 'legacy-2' 'set-exists' )
					LEGACY_LEVEL=2
					# B_RENDER_ACCEL='' # set default to false
					if [ "$B_FORCE_NO_COMPOSITE" != 'true' ];then
						B_COMPOSITE='true'
					fi
					;;
				# This is for the GeForce FX 5xxx series. Not sure about the quadro fx series:
				# 004d 004e 09d0 009d 00cd 00ce 00fe 019d 019e
				004d|004e|09d0|009d|00cd|00ce|00fe|019d|019e|00fa|00fb|00fc|031a|031b|0301|0302|0311|0312|0314|0320|0321|0322|0323|0324|0325|0326|0327|0328|0329|032c|032d|0330|0331|0332|0333|0334|0341|0342|0343|0344|0347|0348)
					DRIVER_INSTALL=$( assign_standard_or_beta_driver 'legacy-3' 'driver' )
					B_BETA_EXISTS=$( assign_standard_or_beta_driver 'legacy-3' 'set-exists' )
					LEGACY_LEVEL=3
					if [ "$B_FORCE_NO_COMPOSITE" != 'true' ];then
						B_COMPOSITE='true'
					fi
					;;
# 				0191|0193)
# 					: # this handles the lack of xvmc support in 8xxx cards
# 					;;
				*)
					# set flags for fully supported non-legacy cards
					B_USE_XVMC='true'
					LEGACY_LEVEL=100
					if [ "$B_FORCE_NO_COMPOSITE" != 'true' ];then
						B_COMPOSITE='true'
					fi
					;;
			esac
			# this handles 8xxx xvmc issue
			if [ -n "$is8xxx" ];then
				B_USE_XVMC='false'
			fi
			# this handles quad cards, whose driver supports both nv legacy and standard cards
			if [ -n "$isQuad" ];then
				: # now quad driver is just latest
				#DRIVER_QUAD=$NV_QUAD
				#DRIVER_INSTALL=$NV_QUAD
			fi
			;;
		1002)
			DRIVER_DEFAULT=$FG_DEFAULT
			DRIVER_TESTING=$FG_TESTING
			VERSIONS=$FG_VERSIONS
			OTHER_VERSIONS=$FG_OTHERS
			CARD_NUMBER=$cardNumber
			case $cardNumber in
				# fireGL cards, temp no support in fglrx
				# http://wiki.cchtml.com/index.php/Hardware
				# note: 4e50 should work with 8.4 driver
				3154|3e54|4147|4154|4a4d|4e47|4e4b|4e54|5464|5550|5551|564a|564b|5b64|5d49|5e48|5e49|71C4)
					LEGACY_LEVEL=0
					error_handler 253
					;;
				# http://listing.driveragent.com/pci/1002/?q=94c3
				0544)
					LEGACY_LEVEL=0
					error_handler 253
					;;
				# removed from list: 4337 - laptop chip
				4136|4137|4237|4242|4243|4336|4337|4354|4358|4437|4554|4654|4742|4744|4747|4749|474c|474d|474e|474f|4750|4751|4752|4753|4754|4755|4756|4757|4758|4759|475a|4964|4965|4966|4967|496e|496f|4c42|4c44|4c45|4c46|4c47|4c49|4c4d|4c4e|4c50|4c51|4c52|4c53|4c54|4c57|4c58|4c59|4c5a|4c64|4c65|4c66|4c67|4c6e|4c6f|4d46|4d4c|4f72|4f73)
					LEGACY_LEVEL=0
					error_handler 253
					;;
				5041|5042|5043|5044|5045|5046|5047|5048|5049|504a|504b|504c|504d|504e|504f|5050|5051|5052|5053|5054|5055|5056|5057|5058|5144|5145|5146|5147|5148|5149|514a|514b|514c|514d|514e|514f|5154|5155|5157|5158|5159|515a|515e|515f|5168|5169|516a|516b|516c|516d|516f|5245|5246|5247|524b|524c|5345|5346|5347|5348|534b|534c|534d|534e|5354|5446|544c|5452|5453|5454|5455|5654|5655|5656|5833|5834|5835|5838|5854|5874|5940|5941|5942|5944|5960|5961|5962|5964|5965|5969|5c41|5c43|5c61|5c63|5d44)
					LEGACY_LEVEL=0
					error_handler 253
					;;
				7c37|728c|7834|7835)
					LEGACY_LEVEL=0
					error_handler 253
					;;
				# a few cards of the 7xxx numbering are actuall x2xxx cards
				# sadly, this doesn't build the module, so leaving it commented out, x series fail
# 				718a|7188|7210|7211)
# 					LEGACY_LEVEL=100
# 					if [ "$B_DISTRO_FLAG" == 'true' ];then
# 						B_USE_DISTRO_DRIVER='true'
# 					fi
# 					;;
				# this is going to handle all pre hd/x2000 cards, any exceptions will be added
				# to an explicit whitelist above this if required
				3*|4*|5*|7*)
					LEGACY_LEVEL=1
					# going to leave this in for now until debian kernels and
					# xorgs catch up, but will permit by default for non legacy 0 cards
					if [ "$B_DISTRO_FLAG" == 'true' ];then
						B_USE_DISTRO_DRIVER='true'
					fi
					;;
				*)
					# if no working driver via standard ati installer. Here we're also handling
					# the monthly releases, so users can do an experimental test if needed
					# if [ "$B_DISTRO_FLAG" == 'true' -a "$B_TESTING_1" != 'true' ]
					LEGACY_LEVEL=100
					if [ "$B_DISTRO_FLAG" == 'true' ];then
						B_USE_DISTRO_DRIVER='true'
					fi
# 					if [ "$B_FORCE_NO_COMPOSITE" != 'true' ];then
# 						B_COMPOSITE='true'
# 					fi
					;;
			esac
			;;
		 # set B_NATIVE_DRIVER so script fires correctly
		 # intel | neomagic | 3dfx
		8086|10c8|121a)
			CARD_NUMBER=$cardNumber
			B_NATIVE_DRIVER='true'
			;;
	esac
	#echo $cardNumber
}

# this is only for nVidia cards so no need to do testing
# args: $1 - default/legacy-[1-3]; $2 - set-exists/driver
assign_standard_or_beta_driver()
{
	local betaDriver='' stableDriver='' liveBetas=''
	local betaCurrent='' beta173='' beta96='' beta71=''
	
	# only run this the first time it's called
	if [ "$B_USE_BETA" == 'true' -a "$1" == 'default' -a "$2" == 'driver' ];then
		liveBetas=$( get_live_nvidia_betas )
		betaCurrent=$( cut -d ':' -f 1 <<< "$liveBetas" )
		beta173=$( cut -d ':' -f 2 <<< "$liveBetas" )
		beta96=$( cut -d ':' -f 3 <<< "$liveBetas" )
		beta71=$( cut -d ':' -f 4 <<< "$liveBetas" )
		## assign live defaults if required
		if [ -n "$betaCurrent" ];then
			if [ -z "$NV_DEFAULT_BETA" -o "$( compare_numbers $betaCurrent $NV_DEFAULT_BETA )" -eq 0 ];then
				NV_DEFAULT_BETA=$betaCurrent
				NV_TESTING="$NV_TESTING:$betaCurrent"
			fi
		fi
		if [ -n "$beta173" ];then
			if [ -z "$NV_LEGACY_BETA_3" -o "$( compare_numbers $beta173 $NV_LEGACY_BETA_3 )" -eq 0 ];then
				NV_LEGACY_BETA_3=$beta173
				NV_TESTING="$NV_TESTING:$beta173"
			fi
		fi
		if [ -n "$beta96" ];then
			if [ -z "$NV_LEGACY_BETA_2" -o "$( compare_numbers $beta96 $NV_LEGACY_BETA_2 )" -eq 0 ];then
				NV_LEGACY_BETA_2=$beta96
				NV_TESTING="$NV_TESTING:$beta96"
			fi
		fi
		if [ -n "$beta71" ];then
			if [ -z "$NV_LEGACY_BETA_1" -o "$( compare_numbers $beta71 $NV_LEGACY_BETA_1 )" -eq 0 ];then
				NV_LEGACY_BETA_1=$beta71
				NV_TESTING="$NV_TESTING:$beta71"
			fi
		fi
	fi

	case $1 in
		default)
			betaDriver=$NV_DEFAULT_BETA
			stableDriver=$NV_DEFAULT
			;;
		legacy-1)
			betaDriver=$NV_LEGACY_BETA_1
			stableDriver=$NV_LEGACY_1
			;;
		legacy-2)
			betaDriver=$NV_LEGACY_BETA_2
			stableDriver=$NV_LEGACY_2
			;;
		legacy-3)
			betaDriver=$NV_LEGACY_BETA_3
			stableDriver=$NV_LEGACY_3
			;;
	esac

	if [ "$2" == 'driver' ];then
		if [ -n "$betaDriver" -a "$B_USE_BETA" == 'true' ];then
			echo $betaDriver
		elif [ -z "$betaDriver" -o "$B_USE_BETA" != 'true' ];then
			echo $stableDriver
		fi
	else
		if [ -n "$betaDriver" -a "$B_USE_BETA" == 'true' ];then
			echo 'true'
		fi
	fi
}

get_live_nvidia_betas()
{
	local driverList='' betaCurrent='' beta173='' beta96='' beta71=''
	
	# get data
	if [ "$B_SKIP_WGET" != 'true' ];then
		driverList="$( wget -T 3 -t 2 -qO - $NV_LIVE_DRIVERS )"
		# get beta drivers
		betaCurrent=$( awk '/^curr.*beta/ {print $3}' <<< "$driverList" )
		beta173=$( awk '/^173.*beta/ {print $3}' <<< "$driverList" )
		beta96=$( awk '/^96.*beta/ {print $3}' <<< "$driverList" )
		beta71=$( awk '/^71.*beta/ {print $3}' <<< "$driverList" )
		driverList="$betaCurrent:$beta173:$beta96:$beta71"
	fi
	# return processed betas
	echo $driverList
}

# this is to get the live data for print out only, for apps that might use this
# this is only for -p script printout, and is triggered by: -p -! 121
reset_using_live_driver_data()
{
	if [ "$B_SKIP_WGET" != 'true' ];then
		local uaFull="-U s-tools/sgfxi-data.tool-data" 
		local driverList="$( wget $uaFull -T 3 -t 2 -qO - http://smxi.org/sg/data/sg-drivers-23 )"
		local nvidiaDefault=$( grep -iA 1 'NVidia Default Stable' <<< "$driverList" | grep 'DEFAULT' )
		local nvidiaBeta=$( grep -iA 1 'Nvidia Beta Drivers' <<< "$driverList" | grep 'DEFAULT' )
		local fglrxDefault=$( grep -iA 1 'Fglrx Main Drivers' <<< "$driverList" | grep 'DEFAULT' )
		
		# reset script locals with remote values, but only if wget succeeded, otherwise use script
		# local values as an acceptable failsafe default.
		if [ -n "$driverList" ];then
			# DEFAULT: 256.53 :: LEGACY 3: 173.14.27 :: LEGACY 2: 96.43.18 :: LEGACY 1: 71.86.14
			NV_DEFAULT=$( awk '{print $2}' <<< "$nvidiaDefault" )
			NV_LEGACY_1=$( awk '{print $6}' <<< "$nvidiaDefault" ) # old, tnt etc
			NV_LEGACY_2=$( awk '{print $10}' <<< "$nvidiaDefault" ) # ge4xx cards
			NV_LEGACY_3=$( awk '{print $14}' <<< "$nvidiaDefault" ) # 5xxx cards
			NV_VERSIONS=$( awk '{print $2 ":" $6 ":" $10 ":" $14 }' <<< "$nvidiaDefault" )
			
			# DEFAULT: 260.19.06 :: LEGACY 3: N/A :: LEGACY 2: N/A  :: LEGACY 1: N/A
			## beta drivers 
			NV_DEFAULT_BETA=$( awk '{print $2}' <<< "$nvidiaBeta" ) # >= 6xxx
			NV_LEGACY_BETA_1=$( awk '{print $6}' <<< "$nvidiaBeta" ) # old, tnt etc
			NV_LEGACY_BETA_2=$( awk '{print $10}' <<< "$nvidiaBeta" ) # ge4xx cards
			NV_LEGACY_BETA_3=$( awk '{print $14}' <<< "$nvidiaBeta" ) # 5xxx cards
			
			# DEFAULT: 10-9 :: PREVIOUS 1: 10-8 :: PREVIOUS 2: 9-3
			# fglrx drivers
			FG_DEFAULT=$( awk '{print $2}' <<< "$fglrxDefault" )
			FG_VERSIONS=$( awk '{print $2 ":" $6 ":" $10 }' <<< "$fglrxDefault" )
		fi
	fi
}

### -------------------------------------------------------------------
### general script utilities
### -------------------------------------------------------------------

# args: $1 - get/set; $2 - prefname
get_set_prefs()
{
	eval $LOGUS
	local etcsm='/etc/smxi.conf' retValue='' name='' value=''

	case $1 in
		get)
			retValue=$( grep -s $2 $etcsm )
			echo $retValue
			log_function_data "Return value: $retValue"
			;;
		set)
			touch $etcsm
			# test = first, this will handle the base name and anything else
			name=$( cut -d '=' -f 1 <<< $2 )
			# check to see if it's there, if it is, it must be a = type thing
			if [ -z "$( grep -s $name $etcsm )" ];then
				echo $2 >> $etcsm
				log_function_data "Added $2 to $etcsm"
			else
				sed -i "s/$name.*/$2/" $etcsm
				log_function_data "Updated $name to $2 in $etcsm"
			fi
			;;
	esac
	eval $LOGUE
}

# handles bug in stub installer that leaves tempfiles uncleaned
cleanup_update_files()
{
	eval $LOGUS
	local all_files="" slxorg='sgfxi-lib-xorg'

	# Note: if  * is in "" the wildcard does not work
	# /dev/null handles case where no temp or original file exists
	all_files=$( ls "${SCRIPT_NAME}."* 2> /dev/null )
	# make sure stuff exists, rm files
	if [ -n "$all_files" ];then
		rm -f $all_files
	fi
	if [ -f $slxorg ];then
		rm -f $slxorg # clean up old xorg lib file
	fi
	if [ -d /usr/src/kernel-downloads -a ! -d $SM_KERNEL_DOWNLOADS  ];then
		mv -f /usr/src/kernel-downloads $SM_KERNEL_DOWNLOADS
	fi
	
	eval $LOGUE
}

# make the default locations for driver run package files
create_data_storage()
{
	local nvidiaPackages='' fglrxPackages='' bMoved='false'
	# don't run this in case of user set test paths
	if [ ! -d "$SCRIPT_WORKING_DIR" -a "$B_TESTING_1" != 'true' ];then
		echo $LINE
		echo "${S}Creating ${C}$SCRIPT_WORKING_DIR${S} to store driver downloads in...${N}"
		mkdir -p $SCRIPT_WORKING_DIR
		rm -f ${USRS}nohup.out &>/dev/null # sometimes these get left over...
		rm -rf /usr/src/nvidia-installer &>/dev/null # this can cause weirdness so dump it
		nvidiaPackages=$( ls ${USRS} 2>/dev/null | grep -Esi '^nvidia' )
		nvidiaPackages=$( echo $nvidiaPackages )
		fglrxPackages=$( ls ${USRS} 2>/dev/null | grep -Esi '^(ati-driver-|fglrx)'  )
		fglrxPackages=$( echo $fglrxPackages )
		log_function_data "nvidiaPackages:\n$nvidiaPackages"
		log_function_data "fglrxPackages:\n$fglrxPackages"
		if [ -n "$nvidiaPackages" ];then
			echo "${S}Moving all existing ${C}nVidia${S} data files to ${C}$SCRIPT_WORKING_DIR${S}...${N}"
			for i in $nvidiaPackages
			do
				if [ -e "${USRS}$i" ];then
					mv -f ${USRS}$i $SCRIPT_WORKING_DIR 2>/dev/null
				fi
			done
			bMoved='true'
		fi
		if [ -n "$fglrxPackages" ];then
			echo "${S}Moving all existing ${C}ATI/fglrx${S} data files to ${C}$SCRIPT_WORKING_DIR${S}...${N}"
			for i in $fglrxPackages
			do
				if [ -e "${USRS}$i" ];then
					mv -f ${USRS}$i $SCRIPT_WORKING_DIR 2>/dev/null
				fi
			done
			bMoved='true'
		fi
		if [ "$bMoved" == 'true' ];then
			echo "${S}Please take note of the updated location for the downloaded drivers.${N}"
			print_hec
		fi
	fi
}

clean_script_data()
{
	check_root
	cd $SCRIPT_HOME

	local downloadDirectorySize='' backupFiles='' backupFilesCount=''
	local opt='' bRepeat='false'
	local options="remove-video-driver-downloads delete-xorg.conf-backup-files uninstall-$SCRIPT_NAME quit" 
	
	echo $MLINE
	echo "${M}$SCRIPT_NAME cleanup tool"
	echo $MLINE
	echo "${S}Calculating cleanup data....${N}"
	echo $LINE
	downloadDirectorySize=$( du -ch $SCRIPT_WORKING_DIR 2>/dev/null | grep 'total' )
	backupFiles=$( ls $EXXC-bu* $EXXC.1st* 2>/dev/null )
	backupFilesCount=$( wc -w <<< $backupFiles )
	echo "${S}The following ${C}$SCRIPT_NAME${S} data exists for possible cleanup in your system"
	echo "$SCRIPT_WORKING_DIR: ${C}$downloadDirectorySize${S}"
	echo "$EXXC-bu* backup files: ${C}$backupFilesCount${S}"
	echo $LINE
	echo "${C}1 - remove-video-driver-downloads${S} - Delete ALL video driver downloads."
	echo "${C}2 - delete-xorg.conf-backup-files${S} - Delete ALL xorg.conf backup files."
	echo "${C}3 - uninstall-$SCRIPT_NAME${S} - Removes ALL pieces of $SCRIPT_NAME. Cannot be undone."
	echo "   Will confirm your choice before proceeding."
	
	echo "${C}4 - quit${S} - Exit now."
	echo $LINE
	select opt in $options
	do
		case $opt in
			remove-video-driver-downloads)
				if [ -d $SCRIPT_WORKING_DIR ];then
					rm -rf $SCRIPT_WORKING_DIR
					echo "${C}$SCRIPT_WORKING_DIR${S} deleted. ${C}$downloadDirectorySize${S} cleaned up.${N}"
				else
					echo "${M}No ${C}$SCRIPT_WORKING_DIR${M} directory present so nothing deleted.${N}"
				fi
				bRepeat='true'
				;;
			delete-xorg.conf-backup-files)
				if [ -n "$backupFiles" ];then
					rm -f $backupFiles
					echo "${C}$backupFilesCount $EXXC-bu*${S} back-up files deleted.${N}"
				else
					echo "${M}No ${C}$EXXC-bu*${M} back-up files present so none deleted.${N}"
				fi
				bRepeat='true'
				;;
			uninstall-$SCRIPT_NAME)
				uninstall_script
				;;
			quit)
				echo "${S}Ok, quitting now.${N}"
				exit 0
				;;
			*)	print_error 'opt'
				bRepeat='true'
				;;
		esac
		break
	done
	
	if [ "$bRepeat" == 'true' ];then
		clean_script_data
	fi
}

uninstall_script()
{
	local opt=''
	local options="yes-uninstall-everything return-main-menu"
	echo $LINE
	echo "${S}Are you sure you want to totally uninstall ${C}$SCRIPT_NAME${S}"
	echo "This will remove $SCRIPT_NAME and all its components permanently!"
	echo $LINE
	echo "${S}Enter a number for your selection and hit enter"
	echo $LINE
	echo "${C}1 - yes-uninstall-everything${S} - Completely uninstall $SCRIPT_NAME and its related."
	echo "    components, logs, and configurations."
	echo "${C}2 - return-main-menu${S} - Go back to main menu, skip the uninstall."
	echo $LINE
	select opt in $options
		do
			case $opt in
				yes-uninstall-everything)
					echo "${S}Ok, removing all the pieces now...${N}"
					rm -rf /var/log/${SCRIPT_NAME}*
					rm -f $EXXC-bu* $EXXC.1st*
					rm -f /etc/logrotate.d/${SCRIPT_NAME}*
					rm -rf $SCRIPT_WORKING_DIR
					rm -f $SCRIPT_HOME/video_support_* $SCRIPT_HOME/sg-drivers*
					rm -f $SCRIPT_HOME/${SCRIPT_NAME}*
					rm -f /etc/modprobe.d/kms-sg-blacklist.conf
					echo "${S}Ok, everything is removed. Exiting since $SCRIPT_NAME is now gone.${N}"
					exit 0
					;;
				return-main-menu)
					echo "${S}Ok, going back to cleanup menu now.${N}"
					;;
			esac
			break
	done
	
	if [ "$bRepeat" == 'true' ];then
		uninstall_script
	fi
}
### -------------------------------------------------------------------
### kernel data and header testing
### -------------------------------------------------------------------

kernel_string_info()
{
	# The kernel variables stuff needs to be in a separate function to get data from
	# either the running kernel or the new installed kernel
	if [ -n "$INSTALL_TO_KERNEL" ];then
		KERNEL_VERSION=$INSTALL_TO_KERNEL
	else
		KERNEL_VERSION=$( uname -r ) # full kernel name
	fi

	if [ -n "$( echo $KERNEL_VERSION | grep -sE "[\.|-]slh\(64\)\?[\.|-]" )" ];then
		B_IS_APTOSID_KERNEL='true'
	fi
	if [ -n "$( grep -si 'CONFIG_XEN=y' /boot/config-$KERNEL_VERSION )" ];then
		B_IS_XEN='true'
	fi
	KERNEL_BASE=$( echo $KERNEL_VERSION | cut -d '.' -f 1-2 ) # like: 2.6
	KERNEL_THREE=$( echo $KERNEL_VERSION | cut -d '-' -f 1 | cut -d '.' -f 1-3 ) # like: 2.6.19
	KERNEL_THIRD=$( echo $KERNEL_VERSION | cut -d '-' -f 1 | cut -d '.' -f 3 ) # like: 19, for math use
	if [ -n "$( grep -is "PAE" <<< $KERNEL_VERSION )" ];then
		FED_KERNEL_PAE='-PAE'
	fi
}

# The best test I've found so far to check whether the kernel exists or not:
test_install_kernel_version()
{
	if [ ! -d /lib/modules/$INSTALL_TO_KERNEL ];then
		echo "${S}These are your currently installed kernels:${C}"
		ls /lib/modules
		echo ${N}
		error_handler 232 $INSTALL_TO_KERNEL
		#comment the line above to debug the kernel_string_info function - Also uncomment the debug lines in that function
	# it passed the test
	else
		kernel_string_info
	fi
}

# this handles a case where there's a kernel header mismatch or
# when they are simply missing, the former is strange, the latter normal
check_kernel_headers()
{
	eval $LOGUS
	local headerName=''
	local headerPresent=''
	local headerInstalled='' testKernel=''
	
	case $SYSTEM_BASE in
		debian|ubuntu)
			headerName="linux-headers-$KERNEL_VERSION"
			headerPresent="$( ls ${USRS}$headerName/ 2>/dev/null )"
			headerInstalled=$( check_package_status "$headerName" 'i' )
			# want to make sure it's available, and not merely referenced
			local headerAvailable=$( check_package_status "$headerName" 'c' )
			local headerFile="$( ls ${SM_KERNEL_DOWNLOADS}/$KERNEL_VERSION/$headerName*.deb 2>/dev/null )"
		
			log_function_data "headerName: $headerName\nheaderInstalled: $headerInstalled\nheaderAvailable: $headerAvailable\nheaderFile: $headerFile"
		
			# first try direct apt install, then dpkg from smxi downloads, then give up
			if [ -n "$headerPresent" ];then
				: # do nothing, it's there
			elif [ -z "$headerInstalled" -a -n "$headerAvailable" ];then
				echo "${S}Installing missing kernel header package ${C}$headerName${S} before proceeding...${N}"
				install_package "$headerName"
			elif [ -z "$headerInstalled" -a -n "$headerFile" -a -f "$headerFile" ];then
				echo "${S}Installing missing kernel header package ${C}$headerName${S}"
				echo "using your archived header package: ${C}$headerFile${N}"
				dpkg -i $headerFile || error_handler 223 "$headerFile"
			elif [ -z "$headerInstalled" -a -z "$headerAvailable" -a "$B_TESTING_5" != 'true' ];then
				error_handler 224 "$headerName"
			fi
			;;
		fedora)
			# fedora 12 headers: /usr/src/kernels/$(uname -r)
			# kernel-PAE-devel-2.6.31.5-127.fc12.i686.rpm
			local kernelDevel='' develPresent='' kernelWorking=''
			# need to slice off .PAE from working kernel name/headers name
			kernelWorking=$( sed -r 's/\.PAE//' <<< $KERNEL_VERSION )
			headerName="kernel-headers-$kernelWorking"
			headerPresent="$( ls ${USRS}kernels/$KERNEL_VERSION/ 2>/dev/null )"
			# rpm is reporting two names here I think, we'll see, if it's got the
			# kernel name in it, we'll call it installed.
			headerInstalled=$( check_package_status "$headerName" 'i' | grep $kernelWorking )
			# if [ -z "$headerPresent" -a -z "$headerInstalled" ];then
			if [ -z "$headerInstalled" ];then
				install_package "$headerName"
			fi
			kernelDevel="kernel$FED_KERNEL_PAE-devel-$kernelWorking"
			develPresent=$( check_package_status "$kernelDevel" 'i' )
			if [ -z "$develPresent" ];then
				install_package "$kernelDevel"
			fi
			;;
		# fresh arch installs do not have the kernel header in /usr/src but this test
		# is highly erratic, arch is not using consistent methods, requires more testing
		arch)
			headerName="kernel26-headers"
			headerPresent="$( ls /lib/modules/$KERNEL_VERSION/build/ 2>/dev/null )"
			testKernel=$( grep -Esi '^2\.6\.[0-9]{2}-ARCH$' <<< $KERNEL_VERSION )
			# 2.6.32-ARCH
			if [ -z "$headerPresent" ];then
				# if it's a custom kernel, no package available so die
				if [ -n "$testKernel" ];then 
					error_handler 224 "$headerName"
				# otherwise let's test for the default, and install it if its missing
				else
					headerInstalled=$( check_package_status "$headerName" 'i' )
					if [ -n "$( check_package_status "$headerName" 'c' )" ];then
						install_package "$headerName"
					else
						error_handler 224 "$headerName"
					fi
				fi
			fi
			;;
	esac
	eval $LOGUE
}

### -------------------------------------------------------------------
### startup and tools testing
### -------------------------------------------------------------------

# note that we want this to print with no root error
check_root()
{
	if [ "$(whoami)" != 'root' -a "$B_PRINT_VER" != 'true' ];then
		error_handler 251
	fi
}

basic_startup_tests()
{
	check_set_distro
	# make sure Xorg is installed
	if [ -z "$( which Xorg )" ];then
		error_handler 244
	fi
	# make sure xorg.conf exists, with xorg > 1.4 exception to handle null xorg.conf
	if [ ! -f $EXXC -a -z "$( echo $X_VERSION | grep -E '[1-2]\.[0-9]' )" ];then
		error_handler 249
	fi
	# double check only 2.6 series kernels
	if [ "$KERNEL_BASE" != '2.6' ];then
		error_handler 243
	fi

	## basic execute requirements
	cd $SCRIPT_HOME
	check_root
	cleanup_update_files
	check_script_depends

	# this allows users to update in x, for example, to see latest drivers
	if [ "$B_FORCE_UPDATE" == 'true' ];then
		check_update_script "$SCRIPT_NAME" "$SCRIPT_DOWNLOAD" 'default server'
	fi

	# only support current systems, xorg >= 7.1/1.x
	if [ -z "$X_VERSION" ];then
		error_handler 242
	fi
	# this corrects a stupid mistake I made
	rm -f *-sgfxi.log # was creating log files in /usr/local/bin
	# test to see if any dm is running, we'll shutdown all wm later though
	if [ -n "$DISPLAY" -a "$B_SKIP_X_TEST" != 'true' -a "$B_KERNEL_MODULE_ONLY" != 'true' -a "$B_PRINT_VER" != 'true' ];then
		error_handler 250
	fi
	case $SYSTEM_BASE in
		ubuntu)
			# we need to confirm that restricted repos are enabled before continuing
			if [ "$B_USE_DISTRO_DRIVER" == 'true' ];then
				update_to_nonfree_sources
			fi
			;;
	esac
}

## basic system requirements for this script to run, first so user doesn't
## have to be root or out of x to get basic failure information
check_set_distro()
{
	local lsbData='' debianVersion='' debianDefault='' workingId=''
	local stableSources='' testingSources='' sidSources=''
	local etcIssue=$( cat /etc/issue 2>/dev/null )
	
	# make sure that it's a debian/arch/ubuntu based system
	# note that mint/ubuntu have file /etc/debian_version so we need to be careful here
	if [ -n "$( grep -si 'buntu' <<< $etcIssue )" ];then
		workingId='ubuntu'
	# mint test, note that for new lmde we are treating it as pure debian
	elif [ -n "$( grep -si 'mint' <<< $etcIssue )" -a -z "$( grep -si 'Linux Mint Debian' <<< $etcIssue )" ];then
		workingId='linuxmint'
	# debian defaults, might miss other ubuntu derived distros but those will
	# be handled as we find them, empirically.
	elif [ -f "$EDV" ];then
		workingId='debian'
		if [ -n "$( grep -si 'Linux Mint Debian' <<< $etcIssue )" ];then
			workingId='linuxmint-debian'
		fi
		# test apt.conf for default version information, this will override everything else
		if [ -n "$( grep -Esi 'APT::Default-Release[[:space:]]+"(stable|etch|lenny)"' $EAA )" ];then
			debianDefault='stable'
		elif [ -n "$( grep -Esi 'APT::Default-Release[[:space:]]+"(testing|squeeze)"' $EAA )" ];then
			debianDefault='testing'
		elif [ -n "$( grep -Esi 'APT::Default-Release[[:space:]]+"(unstable|sid)"' $EAA )" ];then
			debianDefault='sid'
		fi
		# then test /etc/debian_version which will override for stable
		if [ -n "$( grep -Eis '^(squeeze|6\.)' $EDV )" ];then
			debianVersion='squeeze'
		elif [ -n "$( grep -is '^5.' $EDV )" ];then
			debianVersion='lenny'
		elif [ -n "$( grep -is '^4.' $EDV )" ];then
			debianVersion='etch'
		fi
		# then test apt sources themselves
		stableSources=$( grep -Esiw '^[[:space:]]*deb' $EAS $EAS.d/*.list | grep -Eiv "$NON_DEBIAN_PATTERN" | grep -Eicw '([[:space:]]stable|/stable|lenny|etch)' )
		testingSources=$( grep -Esiw '^[[:space:]]*deb' $EAS $EAS.d/*.list | grep -Eiv "$NON_DEBIAN_PATTERN" | grep -Eicw '(squeeze|testing)' )
		sidSources=$( grep -Esiw '^[[:space:]]*deb' $EAS $EAS.d/*.list | grep -Eiv "$NON_DEBIAN_PATTERN" | grep -Eicw '(sid|unstable)' )
	# arch tests
	elif [ -f "$EAR" ] || [ -n "$( grep -si '^arch' <<< $etcIssue  )" ];then
		workingId='arch'
	elif [ -f "$EFR" ] || [ -n "$( grep -si '^fedora' <<< $etcIssue  )" ];then
		workingId='fedora'
	else
		error_handler 252
	fi
	
	# ideally all distros would use lsb-release, but sadly they don't. 
	if [ -s $ELR ];then
		lsbData="$( cat $ELR )"
		DISTRIB_CODENAME=$( grep 'DISTRIB_CODENAME' <<< "$lsbData" | cut -d '=' -f 2 | tr '[A-Z]' '[a-z]' )
		DISTRIB_ID=$( grep 'DISTRIB_ID' <<< "$lsbData" | cut -d '=' -f 2 | tr '[A-Z]' '[a-z]' )
		DISTRIB_RELEASE=$( grep 'DISTRIB_RELEASE' <<< "$lsbData" | cut -d '=' -f 2 | tr '[A-Z]' '[a-z]' )
	fi
	
	case $workingId in
		arch)
			APT_TYPE='pacman'
			DISTRO_FGLRX=$ARCH_FGLRX
			DISTRO_NVIDIA=$ARCH_NVIDIA
			SYSTEM_BASE='arch'
			SYSTEM_CODENAME='arch'
			SCRIPT_HOME='/usr/bin'
			X_NAME='Xorg'
			;;
		debian|linuxmint-debian)
			DISTRO_FGLRX=$DEBIAN_FGLRX
			DISTRO_NVIDIA=$DEBIAN_NVIDIA
			FG_DISTRIB_ID='Debian'
			SYSTEM_BASE='debian' # debian not using elr file yet
			if [ "$workingId" == 'linuxmint-debian' ];then
				APT_TYPE='apt-get'
			fi

			# set system type. This test will never be perfect, but it's a good approximation
			if [ "$debianDefault" == 'stable' ] || [ "$debianVersion" == 'etch' -o "$debianVersion" == 'lenny' ] || [ "$stableSources" -gt 0 -a "$sidSources" -eq 0 -a "$testingSources" -eq 0 ];then
				if [ "$debianVersion" == 'etch' ];then
					FG_DISTRIB_CODENAME='etch'
					SYSTEM_CODENAME='etch'
				else
					FG_DISTRIB_CODENAME='lenny' # note: 'stable' breaks the installer
					SYSTEM_CODENAME='stable'
				fi
			elif [ "$debianDefault" == 'testing' ] || [ "$sidSources" -eq 0 -a "$testingSources" -gt 0 ];then
				FG_DISTRIB_CODENAME='sid'
				SYSTEM_CODENAME='testing'
			else
				FG_DISTRIB_CODENAME='sid'
				SYSTEM_CODENAME='sid'
			fi
			X_NAME='X'
			# these will be used for various advanced tests in some components
			if [ -z "$DISTRIB_ID" ];then
				if [ -f /etc/aptosid-version ];then
					DISTRIB_ID='aptosid'
				elif [ -f /etc/sidux-version ];then
					DISTRIB_ID='sidux'
				elif [ -f /etc/antix-version ];then
					DISTRIB_ID='antix'
				fi
			fi
			;;
		fedora)
			APT_TYPE='yum'
			DISTRO_FGLRX=$FEDORA_FGLRX
			DISTRO_NVIDIA=$FEDORA_NVIDIA
			FG_DISTRIB_ID='Fedora'
			FG_DISTRIB_CODENAME=''
			SYSTEM_BASE='fedora'
			if [ -f "$EFR" ];then
				DISTRIB_CODENAME=$( grep -si 'Fedora' $EFR | sed -r 's/Fedora.*\((.*)\)/\1/i' )
				SYSTEM_CODENAME=$( grep -si 'Fedora' $EFR | sed -r 's/Fedora.*[[:space:]]([0-9]+)[[:space:]]\(.*\)/\1/i' )
			fi
			X_NAME='X'
			;;
		linuxmint)
			APT_TYPE='apt-get'
			DISTRO_FGLRX=$UBUNTU_FGLRX
			DISTRO_NVIDIA=$UBUNTU_NVIDIA
			FG_DISTRIB_ID='Ubuntu'
			SYSTEM_BASE='ubuntu'
			# need to double check here for fglrx deb builder
			case $DISTRIB_RELEASE in
				6)	FG_DISTRIB_CODENAME='intrepid'
					SYSTEM_CODENAME='intrepid'
					;;
				7)	FG_DISTRIB_CODENAME='jaunty'
					SYSTEM_CODENAME='jaunty'
					;;
				8)	FG_DISTRIB_CODENAME='karmic'
					SYSTEM_CODENAME='karmic'
					;;
				9)	FG_DISTRIB_CODENAME='lucid'
					SYSTEM_CODENAME='lucid'
					;;
			esac
			X_NAME='X'
			;;
		ubuntu)
			DISTRO_FGLRX=$UBUNTU_FGLRX
			DISTRO_NVIDIA=$UBUNTU_NVIDIA
			FG_DISTRIB_ID='Ubuntu'
			FG_DISTRIB_CODENAME=$DISTRIB_CODENAME
			SYSTEM_BASE='ubuntu'
			SYSTEM_CODENAME=$DISTRIB_CODENAME
			X_NAME='X'
			;;
		*)
			## basic system requirements for this script to run, first so user doesn't
			## have to be root or out of x to get basic failure information
			# make sure that it's a debian based system
			error_handler 252
			;;
	esac
	if [ -z "$DISTRIB_ID" ];then
		DISTRIB_ID=$SYSTEM_BASE
	fi
	if [ -z "$DISTRIB_CODENAME" ];then
		DISTRIB_CODENAME=$SYSTEM_CODENAME
	fi
	SIS=$DISTRIB_ID-$DISTRIB_CODENAME-$BITS
}

check_run_package_tools()
{
	eval $LOGPS
	local makePath=$( type -p make )
	local patchPath=$( type -p patch )
	
	if [ -z "$makePath" ];then
		if [ -n "$( check_package_status 'make' 'c' )" ];then
			install_package 'make'
		fi
	fi
	if [ -z "$patchPath" ];then
		if [ -n "$( check_package_status 'patch' 'c' )" ];then
			install_package 'patch'
		fi
	fi
	
	eval $LOGPE
}

check_script_depends()
{
	eval $LOGPS
	local wgetPath=$( type -p wget )
	local logrotatePath=$( type -p logrotate )
	
	if [ -z "$wgetPath" ];then
		if [ -n "$( check_package_status 'wget' 'c' )" ];then
			install_package 'wget'
		fi
	fi
	if [ -z "$logrotatePath" ];then
		if [ -n "$( check_package_status 'logrotate' 'c' )" ];then
			install_package 'logrotate'
		fi
	fi
	eval $LOGPE
}

check_driver_install_tools()
{
	eval $LOGPS
	
	local fakerootPath=$( type -p fakeroot )
	
	# nvidia and fglrx tools check_package_status
	case $SYSTEM_BASE in
		debian|ubuntu)
			if [ -z "$( check_package_status 'module-assistant' 'i' )" ];then
				if [ -n "$( check_package_status 'module-assistant' 'c' )" ];then
					install_package 'module-assistant'
				fi
			fi
			if [ -z "$( check_package_status 'build-essential' 'i' )" ];then
				if [ -n "$( check_package_status 'build-essential' 'c' )" ];then
					install_package 'build-essential'
				fi
			fi
			;;
# 		arch)
# 			if [ -z "$( check_package_status 'gcc' 'i' )" ];then
# 				if [ -n "$( check_package_status 'gcc' 'c' )" ];then
# 					install_package 'gcc'
# 				fi
# 			fi
# 			;;
	esac
	
	if [ -z "$fakerootPath" ];then
		if [ -n "$( check_package_status 'fakeroot' 'c' )" ];then
			install_package 'fakeroot'
		fi
	fi
	# note wget test needs to be in first main test function

	if [ "$CARD" == $NVIDIA ];then
		:
	# fglrx tools and tests
	elif [ "$CARD" == $FGLRX ];then
		case $SYSTEM_BASE in
			debian|ubuntu)
				if [ -z "$( check_package_status 'debhelper' 'i' )" ];then
					if [ -n "$( check_package_status 'debhelper' 'c' )" ];then
						install_package 'debhelper'
					fi
				fi
				# presence of this package will break fglrx install
				if [ -n "$( check_package_status 'dpkg-cross' 'i' )" ];then
					remove_package 'dpkg-cross' "$CARD"
				fi
				if [ -z "$( check_package_status 'libstdc++5' 'i' )" ];then
					if [ -n "$( check_package_status 'libstdc++5' 'c' )" ];then
						install_package 'libstdc++5'
					fi
				fi
				if [ -z "$( check_package_status 'libstdc++6' 'i' )" ];then
					if [ -n "$( check_package_status 'libstdc++6' 'c' )" ];then
						install_package 'libstdc++6'
					fi
				fi
				;;
		esac
	fi

	eval $LOGPE
}

# compare 2 dot [5.34.6] or 1/0 dot [3.45, 3] version numbers
# return codes: 0 - $1 > $2; 1 - $1 == $2; 2 - $1 < $2
# note: this also works for one dot, like 3.4, and for 0 dot, like 3
# note: this function will always be sent . type numbers, and it handles any
# localization re decimal indicators internally, otherwise it's too much of a pain.
compare_numbers()
{
	eval $LOGUS
	## DEBUGGER
	# echo $1 $2
	# first we need to determine what the base system is using for decimal indicator
	local returnValue=''
	local decimalType=$( echo 1 | awk '{total = 1 / 2; print total}' | egrep -o '(\.|,)' )

	# next we'll get the raw data and transate it if required
	local numOne=$( cut -d '.' -f 1-2 <<< $1 | tr '.' $decimalType )
	local subOne=$( cut -d '.' -f 3 <<< $1 )
	if [ -z "$subOne" ];then
		subOne=0
	fi
	local numTwo=$( cut -d '.' -f 1-2 <<< $2 | tr '.' $decimalType )
	local subTwo=$( cut -d '.' -f 3 <<< $2 )
	if [ -z "$subTwo" ];then
		subTwo=0
	fi
	local test1=$( echo $numOne $numTwo | awk '{if ( $1 > $2 ) print 0;else print 1}' )
	local test2=$( echo $numOne $numTwo | awk '{if ( $1 == $2 ) print 0;else print 1}' )
	local test3=$( echo $subOne $subTwo | awk '{if ( $1 > $2 ) print 0;else print 1}' )
	local test4=$( echo $subOne $subTwo | awk '{if ( $1 == $2 ) print 0;else print 1}' )
# 	 echo -e "test1 $test1\ntest2 $test2\ntest3 $test3\ntest4 $test4"

	# first case, x > y, and not equal
	if [ "$test1" -eq 0 ];then
		returnValue=0
	# second case, x = y
	elif [ "$test2" -eq 0 ];then # only when x = y, 3.2 = 3.2
		# sub number a > b
		if [ "$test3" -eq 0 ];then
			returnValue=0
		# sub number a = b
		elif [ "$test4" -eq 0 ];then
			returnValue=1
		# sub number a < b
		else
			returnValue=2
		fi
	# if the x is less than y
	else
		returnValue=2
	fi

	echo $returnValue
	log_function_data "returnValue: $returnValue"
	eval $LOGUE
}
## DEBUGGER
# compare_numbers 195 195.53 ;exit

### -------------------------------------------------------------------
### package manager tools
### -------------------------------------------------------------------

check_apt_aptitude()
{
	eval $LOGUS
	local opt='' managers='apt-get aptitude quit'
	local aptPref=$( get_set_prefs 'get' 'apt-type' | cut -d '=' -f 2 | grep -E '^(apt-get|aptitude)$' )
	
	# always override first of all
	if [ -n "$aptPref" ];then
		APT_TYPE=$aptPref
	else
		if [ -f /var/log/aptitude ];then
			case $SYSTEM_BASE in
				debian)
					# leave mint debian using apt-get
					if [ -z "$( type -P apt )" ];then
						echo $LINE
						echo "${S}It appears you are using aptitude. It is not good to mix apt-get and aptitude."
						echo "Please pick your preferred package manager before you continue, or exit now."
						echo
						echo "Your selection (for example: ${C}apt-type=apt-get${S}) will be stored in ${C}/etc/smxi.conf${S}"
						echo "${C}smxi${S} will also use this choice for its default package manager, so make sure it's correct."
						echo $LINE
			
						select opt in $managers
						do
							case $opt in
								apt-get|aptitude)
									APT_TYPE=$opt
									log_function_data "Selected package manager: $opt"
									get_set_prefs 'set' "apt-type=$opt"
									;;
								quit)
									echo "${S}Ok, figure it out and try again later...${N}"
									exit 0
									;;
								*)
									echo "${E}You have to pick one before you can continue!${N}"
									ask_apt_aptitude
									;;
							esac
							break
						done
					else
						log_function_data "Derived Mint Debian using apt wrapper - default to apt-get."
					fi
					;;
				ubuntu)
					# going to ignore linuxmint's apt wrapper method
					if [ -z "$( type -P apt )" ];then
						APT_TYPE='aptitude'
						log_function_data "Ubuntu hardset to aptitude. If not ubuntu then error."
					else
						log_function_data "Derived Ubuntu using apt wrapper - default to apt-get."
					fi
					;;
			esac
		fi
	fi
	
	case $APT_TYPE in
		aptitude)
			WITHOUT_RECOMMENDS='--without-recommends'
			;;
	esac
	
	eval $LOGUE
}

# Returns null if package is not available in user system apt.
# args: $1 - package to test; $2 c/i
check_package_status()
{
	eval $LOGUS
	local packageVersion='' statusType=''

	case $2 in
		c)	statusType='Candidate:'
			;;
		i)	statusType='Installed:'
			;;
	esac
	case $APT_TYPE in
		apt-get|aptitude)
			LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= packageVersion=$( apt-cache policy $1 2>/dev/null | grep -i "$statusType" | cut -d ':' -f 2-4 | cut -d ' ' -f2 | grep -iv '\(none\)' )
			;;
		pacman)
			case $2 in
				c)
					LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= packageVersion=$( pacman -Si "$1" 2>/dev/null | grep -i '^Version' | awk '{print $3}'  )
					;;
				i)
					LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= packageVersion=$( pacman -Q "$1" 2>/dev/null | awk '{print $2}'  )
					;;
			esac
			;;
		yum)
			case $2 in
				c)
					LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= packageVersion=$( yum list "$1" 2>/dev/null | grep -Esvi '(presto|packagekit|packages)'| awk '{print $2}' )
					;;
				i)
				LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= packageVersion=$( rpm -qa 2>/dev/null | grep -Esvi '(presto|packagekit|packages)' | grep -is "$1"   )
					;;
			esac
			;;
	esac

	echo $packageVersion
	log_function_data "Package Version: $packageVersion"
	eval $LOGUE
}

# arg: $1 - package name; $2 - /experimental/unstable/testing/stable; $3 - reinstall
# optional args. Note that if you use 3, you have to set 2 by '' if blank.
install_package()
{
	eval $LOGUS
	local distroVersion='' optionalArgs='' 
	local useUntrusted='' install=''
	local packageInstalled=''
	local update='' install='' doYes='' useUntrusted=''
	
	case $APT_TYPE in
		aptitude)
			doYes=''
			install='install'
			update='update'
			if [ "$SYSTEM_CODENAME" == 'etch' ];then
				useUntrusted='' # etch aptitude doesn't support this
			else
				useUntrusted='--allow-untrusted'
			fi
			;;
		apt-get)
			doYes='-y'
			install='install'
			update='update'
			useUntrusted='--allow-unauthenticated'
			;;
		pacman)
			doYes=''
			update='-Sy'
			install='-S'
			useUntrusted=''
			;;
		yum)
			doYes='' # note: -y is used, but for debugging we'll wait to add that.
			update=''
			install='install'
			useUntrusted='' # check later
			;;
	esac
	if [ -n "$update" ];then # yum has no update repo data command, it does it automatically
		update_package_manager "$update"
	fi

	# this will force install of sid to get rid of experimental if required
	case $SYSTEM_BASE in
		debian)
			if [ -n "$2" ];then
				distroVersion="/$2" #  --force-yesrequird to avoid apt downgrade error
			fi
			;;
	esac
	# only do reinstall if arg is set and package is installed
	case "$3" in
		reinstall)
			packageInstalled=$( check_package_status "$1" 'i' )
			if [ -n "$packageInstalled" ];then
				case $APT_TYPE in
					aptitude)
						optionalArgs=''
						install='reinstall'
						;;
					apt-get)
						optionalArgs=' --reinstall '
						;;
					pacman)
						optionalArgs=''
						;;
					yum)
						optionalArgs=''
						install='reinstall'
						;;
				esac
			fi
			;;
		*)
			case $APT_TYPE in
				pacman)
					optionalArgs=$3
					;;
			esac
			;;
	esac
	# then install the package with all options
	echo "${S}Updating required package ${C}$1${S} now...${N}"
	$APT_TYPE $install $useUntrusted $WITHOUT_RECOMMENDS $doYes $optionalArgs $1$distroVersion || error_handler 200 $1
	eval $LOGUE
}

# args: $1 - update type / name
update_package_manager()
{
	if [ "$B_UPDATED" != 'true' ];then
		$APT_TYPE $1 && B_UPDATED='true'
	fi
}

# args: $1 - package to test for; $2 - excludes from list
list_installed_packages()
{
	eval $LOGUS
	local packageList=''
	
	case $APT_TYPE in
		apt-get|aptitude)
			packageList=$( dpkg -l | awk '{print $2}' | grep -i "$1" | grep -Ev "$2" )
			;;
		pacman)
			packageList=$( pacman -Q | awk '{print $1}' | grep -i "$1" | grep -Ev "$2" )
			;;
		yum)
			packageList=$( rpm -qa | awk '{print $1}' | grep -i "$1" | grep -Ev "$2" )
			;;
	esac
	log_function_data "packageList: $packageList"
	echo $packageList
	eval $LOGUE
}

# $1 - package(s) to remove; $2 - extra information; $3 - no-loop: remove all at once
remove_package()
{
	eval $LOGUS
	local response='' package='' purge='' extraInfo="$2"
	case $APT_TYPE in
		aptitude|apt-get)
			purge='purge'
			;;
		pacman)
			purge='-R'
			;;
		yum)
			purge='erase'
			;;
	esac
	
	if [ -n "$extraInfo" ];then
		extraInfo=" $extraInfo"
	fi

	echo $MLINE
	echo "${M}You will need to remove the following package(s): ${C}$1"
	echo "${M}in order to proceed with your${C}$extraInfo${M} driver install${N}"
	echo $MLINE
	if [ "$3" == 'no-loop' ];then
		echo "${S}Removing ${C}$1${S}...${N}"
		$APT_TYPE $purge $1 || error_handler 190 "$1"
	else
		for package in $1
		do
			if [ -n "$( check_package_status  "$package" 'i' )" ];then
				echo "${S}Removing ${C}$package${S}...${N}"
				$APT_TYPE $purge $package || error_handler 190 "$package"
			else
				echo "${S}The package ${C}$package${S} is not installed, continuing...${N}"
			fi
		done
	fi
 	echo "${S}Package(s) removed successfully, continuing with driver install.${N}"
 	eval $LOGUE
}

# args: $1 - package to hold. sets hold for apt-get/aptitude
hold_package()
{
	eval $LOGUS
	# first set for aptitude syntax
	case $APT_TYPE in
		aptitude|apt-get)
			if [ "$APT_TYPE" == 'aptitude' ];then
				$APT_TYPE hold $1
			fi
			# then set hold into dpkg
			echo $1 hold | dpkg --set-selections
			;;
		pacman)
			:
			;;
		yum)
			:
			;;
	esac
	eval $LOGUE
}

update_to_nonfree_sources()
{
	eval $LOGPS
	
	local isFree=0 i='' counter=0
	local eas='/etc/apt/sources.list'
	local easdl='/etc/apt/sources.list.d/debian.list'
	local eassl='/etc/apt/sources.list.d/aptosid.list'
	local aptProx='' 
	local ubRestricted='' ubMultiverse='' ubUniverse=''
	local yumFreeRepo='' yumNonFreeRepo='' yumList='' bRepoAdded='false'
	
	if [ "$B_USE_DISTRO_DRIVER" == 'true' ];then
		case $SYSTEM_BASE in
			debian)
				# loop through possible files to update
				for i in $eas $easdl $eassl
				do
					if [ -f "$i" ];then
						counter=$( grep -Ec 'deb.*debian\.org.*(contrib|non-free)' $i )
						isFree=$(( $counter + $isFree ))
					fi
				done
			
				if [ "$isFree" -eq 0 ];then
					for i in $eas $easdl $eassl
					do
						if [ -f "$i" ];then
							# I'm going to assume if the user has proxy stuff set up, they know what
							# they are doing here.
							aptProx=$( grep -Esi '^[[:space:]]*deb.*:9999/' $i )
							if [ -z "$aptProx" ];then
								echo "${S}Updating your ${C}$i${S} to use non-free / contrib now...${N}"
								sed -i -r 's%(#?deb.*(debian\.org|sidux\.com|sidux\.net|debian\.tu-bs\.de|mirrorservice\.org|heanet\.ie|spline\.de|sunsite\.utk\.edu|leg\.uct\.ac\.za|mirror\.aarnet\.edu\.au).*\s(main|fix\.main))(\s*)(non-free.*|contrib.*)*%\1 contrib non-free%' $i
								# the second test requires the results of the first to work
								# note that spaces are required for this to work more reliably for most patterns
								sed -i -r 's%(#?deb.*(sidux\.com|sidux\.net|debian\.tu-bs\.de|mirrorservice\.org|heanet\.ie|spline\.de|sunsite\.utk\.edu|ftp-mirror\.internap\.com|ftp\.tw.debian\.org|leg\.uct\.ac\.za|mirror\.aarnet\.edu\.au).*\snon-free)%\1 firmware fix.contrib fix.non-free %' $i
							fi
						fi
					done
					$APT_TYPE update && B_UPDATED='true' # need to refresh
				fi
				;;
			ubuntu)
				# just to make sure, want to get out fast
				ubRestricted=$( grep -siE '^[[:space:]]*deb[[:space:]].*ubuntu.*restricted' $eas $eas.d/*.list )
				if [ -z "$ubRestricted" ];then
					error_handler 216
				fi
				;;
			fedora)
				yumList="$( yum repolist )"
				yumFreeRepo=$( grep  -Eis '^rpmfusion-free.*enabled' <<< "$yumList" )
				yumNonFreeRepo=$( grep  -Eis '^rpmfusion-nonfree.*enabled' <<< "$yumList" )
				echo -n "${S}Checking for ${C}rpmfusion free${S} repos.... ${N}"
				if [ -z "$yumFreeRepo" ];then
					echo "${S}Adding${N}"
					rpm -Uvh http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-stable.noarch.rpm
					bRepoAdded='true'
				else
					echo "${S}Present${N}"
				fi
				echo -n "${S}Checking for ${C}rpmfusion non-free${S} repos.... ${N}"
				if [ -z "$yumNonFreeRepo" ];then
					echo "${S}Adding${N}"
					rpm -Uvh http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpm
					bRepoAdded='true'
				else
					echo "${S}Present${N}"
				fi
				if [ "$bRepoAdded" == 'true' ];then
					echo "${S}Please note that you will be asked during the distro driver install to accept the"
					echo "repo ${C}GPG keys${S} for the repos you just added. Make sure to enter ${C}y${S} for this question.${N}"
					print_hec
				fi
				;;
		esac
	fi
	eval $LOGPE
}

# if null, this will trigger a first run update, maybe in the future can also
# add time of last update tests, we'll see. For now returns size in MB for tests
check_package_manager_updated()
{
	eval $LOGUS
	local dpkguf='/var/cache/apt/pkgcache.bin'
	local sizeWorking=0
	
	case $SYSTEM_BASE in
		debian|ubuntu)
			# this covers the case of first install, no apt update yet, which
			# makes the following  c tests all fail. This will never be true from
			# sm fired sessions since smxi always updates first. Or updates
			# if apt cache file is less than 5mB
			if [ -f $dpkguf ];then
				# dpkgUpdate=$( ls -l --time-style=+%Y-%m-%d-%H:%M $dpkguf | grep -Eo "20[0-9]{2}-[0-9]{2}-[0-9]{2}-[0-9]{2}:[0-9]{2}" )
				sizeWorking=$( du -B M $dpkguf | grep -Eo '^[0-9]+' )
			fi
			log_function_data "sizeWorking: $sizeWorking"
			if [ "$sizeWorking" -lt 4 ];then
				update_package_manager 'update'
			fi
			;;
	esac

	eval $LOGUE
}


### -------------------------------------------------------------------
### script updating / patch file install tools
### -------------------------------------------------------------------

# args: $1 script to get/check; $2 - which download source to use
# $3 - extra message; $4 - repeat, to only retest download failure once
check_update_script()
{
	local fileDataTemp='' isGood='' extraText='' bRunUpdate='false'
	local versionTest=0 versionData='' localVersion='' remoteVersion=''
	local downloadUrl=$2 uArgs='up' ua="-U s-tools/$SCRIPT_NAME"
	local origXorg='/etc/X11/xorg-conf-orig-sg'

	if [ -n "$( grep -E '(dev|svn|alt)' <<< $3 )" ];then
		extraText="${C}$3:\n$2${S}"
	else
		extraText="${C}$3${S}"
	fi
	cd $SCRIPT_HOME # make sure we're in the right place
	# download / replace requested file
	case $1 in
		$SCRIPT_NAME)
			if [ "$B_FORCE_UPDATE" == 'true' ];then
				uArgs='ufr'
				bRunUpdate='true'
			elif [ "$4" == 'repeat' ];then
				uArgs='rep'
				bRunUpdate='true'
			# uncomment if you need this to not trigger for dev purposes
# 			elif [ "$B_TESTING_5" == 'true' ];then
# 				uArgs='dev'
# 				bRunUpdate='true'
			else
				echo -n "${S}Checking ${C}$SCRIPT_NAME${S} versions.... ${N}"
				# 0: same versionp; 1 - different version; 2 - download error
				versionData=$( check_script_version )
				versionTest="$?"
				localVersion=$( cut -d ':' -f 1 <<< "$versionData" )
				remoteVersion=$( cut -d ':' -f 2 <<< "$versionData" )
				if [ "$versionTest" -eq 0 ];then
					echo "${S}local and remote versions match. Continuing...${N}"
					bRunUpdate='false'
				elif [ "$versionTest" -eq 1 ];then
					echo "${M}update required:${S} local: ${C}$localVersion${S} - remote: ${C}$remoteVersion${N}"
					bRunUpdate='true'
				else
					echo "${E}Failed to aquire remote version data. ${S}Will try direct download instead.${N}"
					bRunUpdate='true'
				fi
			fi
			# this will try to download again, the version tester itself isn't going to do any
			# kind of error handling
			if [ "$bRunUpdate" == 'true' ];then
				ua="$ua.$uArgs.$SIS"
				echo -e "${S}Updating ${C}$SCRIPT_NAME${S} now using the $extraText${N}"
				fileDataTemp="$( wget $ua -q -O - $downloadUrl$1 )" || error_handler 198 $1
				# all smxi files have this string as last line, if there, the file should usually
				# run fine, except for weird fringe cases where the ascii file is corrupted partially
				isGood=$( grep -si '##\*\*EOF\*\*##' <<< "$fileDataTemp" )
				if [ -n "$isGood" ];then
					echo "$fileDataTemp" > $1
					chmod 705 $1
					if [ "$B_FORCE_UPDATE" != 'true' ];then
						./$1 -R$START_OPTIONS
					else
						print_information
						echo "${C}$SCRIPT_NAME${S} was successfully updated. Please start the script again to access"
						echo "the latest features and drivers. Remember that ${C}$SCRIPT_NAME${S} always updates itself"
						echo "automatically when it starts so usually ${C}-U${S} is not required."
						echo
						echo "To see the latest drivers or support features, use the ${C}-L${S} option. You can"
						echo "run this option in X, and you don't need to be root to use it. Features:"
						echo "Show all currently supported drivers: ${C}$SCRIPT_NAME -L d${S}"
						echo "Show current nVidia support status: ${C}$SCRIPT_NAME -L n${S}"
						echo "Show current ATI/Fglrx support status: ${C}$SCRIPT_NAME -L f${S}"
						echo "Show current local/remote ${C}$SCRIPT_NAME${S} versions: ${C}$SCRIPT_NAME -L v${S}"
						print_hec
						echo "${S}Update completed. Exiting now.${N}"
					fi
					exit 0
				else
					if [ "$4" != 'repeat' ];then
						# let's try this once again to make sure it wasn't just a temp problem
						echo -e "${E}The file ${C}$1${E} did not download correctly from:\n$2\nRetrying download now...${N}"
						check_update_script "$1" "$2" "$3" 'repeat'
					else
						error_handler 231 $1
					fi
				fi
			fi
			;;
		# I'm only going to load this stuff one time per file so I won't
		# have to worry about rechecking and multi downloads etc
		*)
			if [ "$B_SKIP_WGET" != 'true' ];then
				fileDataTemp="$( wget -q -O - $downloadUrl$1 )" || error_handler 198 $2$1
			fi
			# run fine, except for weird fringe cases where the ascii file is corrupted partially
			isGood=$( grep '##\*\*EOF\*\*##' <<< "$fileDataTemp" )
			if [ -n "$isGood" ];then
				case $1 in
					*xorg-conf)
						echo "${S}Updating ${C}$EXXC${S} to new ${C}$1${S} version now...${N}"
						if [ ! -f $origXorg ];then
							echo "${S}Backing up your original ${C}$EXXC${S} to ${C}$origXorg${S}...${N}"
							mv -f $EXXC $origXorg
						else
							echo "${S}Your original ${C}$EXXC${S} has already been backed up to ${C}$origXorg${S}"
						fi
						echo "${S}Replacing your ${C}$EXXC${S} with ${C}$1${S} now...${N}"
						echo  "$fileDataTemp" > $EXXC
						chmod 604 $EXXC
						echo "${S}All done with the ${C}$EXXC${S} update."
						echo "Try running ${C}$SCRIPT_NAME${S} again and see if your driver install works this time.${N}"
						;;
					*)
						echo  "$fileDataTemp" > $1
						chmod 604 $EXXC
						source ./$1 # load the library file
						;;
				esac
			else
				error_handler 199 $1 # if corrupted file, exit with file name + error
			fi
			;;
	esac
}
# return values: # 0: same versionp; 1 - different version; 2 - download error
check_script_version()
{
	local returnValue=0 wgetError=0 validated='' versionData=''
	local ua="-U s-tools/$SCRIPT_NAME-updater.$SIS"
	local localVersion='' remoteVersion=''
	if [ "$B_SKIP_WGET" == 'true' ];then
		returnValue=2
	else
		versionData="$( wget $ua -qO - $SCRIPT_DOWNLOAD_VERSION )" || wgetError="$?"
		if [ "$wgetError" -eq 0  ];then
			validated=$( grep -Esi '#\*\*EOF\*\*#' <<< "$versionData" )
			if [ -n "$validated" ];then
				localVersion=$( awk '/^#.*[[:space:]]version:/ {print $3}' $SCRIPT_HOME/$SCRIPT_NAME )
				remoteVersion=$( grep 'sgfxi' <<< "$versionData" | cut -d '=' -f 2 | cut -d ':' -f 1 )
				if [ "$localVersion" == "$remoteVersion" ];then
					returnValue=0
				else
					returnValue=1
				fi
				echo "$localVersion:$remoteVersion"
			else
				returnValue=2
			fi
		else
			returnValue=2
		fi
	fi
	return $returnValue
}

# args: $1 patch file to apply
apply_patch_file()
{
	eval $LOGUS
	local patchFile=$1
	## this can be changed to branches with -! 20 or -! 21
	local patchUrl="${PATCH_DOWNLOAD}patches/$patchFile" ua="-U s-tools/$SCRIPT_NAME-data.patches.$patchFile"
	local patchFileDataTemp=''

	cd $SCRIPT_WORKING_DIR/$INSTALL_DIRECTORY # first change to the correct directory
	log_function_data "Patch File Dir: $SCRIPT_WORKING_DIR/$INSTALL_DIRECTORY"
	log_function_data "Patch URL: $patchUrl"

	echo "${S}Retrieving patch ${C}$patchFile${S}...${N}"
	# get patch file, set to variable
	patchFileDataTemp="$( wget $ua -q -O - $patchUrl 2>/dev/null )" || error_handler 180 $patchFile
	if [ -n "$patchFileDataTemp" ];then
		echo "${S}Running patch ${C}$patchFile${S}...${N}"
		patch -p 0 <<< "$patchFileDataTemp" || error_handler 179 $patchFile
		echo "${S}Patching completed...${N}"
	else
		error_handler 181 $patchFile
	fi
	eval $LOGUE
}

### -------------------------------------------------------------------
### print data functions
### -------------------------------------------------------------------

print_information()
{
	local scriptVersion=$( grep -Eo -m 1 "(version:).*" $SCRIPT_HOME/$SCRIPT_NAME | cut -d ' ' -f 2 )
	local scriptDate=$( grep -Eo -m 1 '(Date:).*' $SCRIPT_HOME/$SCRIPT_NAME | cut -d ' ' -f 2-4 )
	#local cardInfo=$( lspci | awk -F': ' '/VGA compatible controller.*: / { print $NF }' | sed -r 's%(ATI\sTechnologies\sInc\s|nVidia\sCorporation\s)(.*)%\2%'  )
	local cardInfo=$( lspci | awk -F': ' '/VGA compatible controller.*: / { print $NF }' | sed -r 's%(ATI\s|nVidia\s|Intel\s)(Technologies\sInc\s|Corporation\s|Unknown\sdevice){1,2}(.*)%\1\3%g' )
	local cardRam='' cardVendor='' busId=''

	# we need the real busid, not the xorg one
	busId=$( lspci -n | grep "$CARD_DATA" | grep -Eio '^[0-9]{1,2}:[0-9a-z]{1,2}(\.|:)[0-9]' )

	if [ -n "$busId" ];then
		cardRam=$( lspci -v -s $busId 2>/dev/null | grep -E '.*Memory[[:space:]].*[[:space:]]prefetchable.*\[size=([0-9\.]+[KMG])\]' | sed -r 's/.*Memory[[:space:]].*[[:space:]]prefetchable.*\[size=([0-9\.]+[KMG])\]/\1/' )
		cardVendor=$( lspci -v -s $busId 2>/dev/null | grep -E '.*Subsystem:[[:space:]]*(.*)' | sed -r 's/.*Subsystem:[[:space:]]*(.*)/\1/' | sed 's/[dD]evice.*$//g' | sed 's/[uU]nknown//g' )
	fi
	echo $MLINE
	echo " ${M}$SCRIPT_NAME${S} :: version: ${C}$scriptVersion${S} :: last updated: ${C}$scriptDate"
	echo $MLINE
	echo " ${S}graphics card information:"
	echo "   ${S}series: ${C}$cardInfo"
	if [ -n "$cardVendor" ];then
		echo "   ${S}vendor: ${C}$cardVendor"
	fi
	if [ -n "$cardRam" ];then
		echo "   ${S}ram:    ${C}$cardRam ${S}(note: not accurate for built in graphics)"
	fi
	echo $MLINE
}
#print_information

# args: $1 testing or standard; $2 function/feature name; $3 function name
print_information_continue()
{
	eval $LOGUS
	local response=''

	case $1 in
		standard|info)
			echo -e "${S}$2"
			;;
	esac

	if [ "$1" == 'standard' ];then
		if [ "$B_AUTORUN" != 'true' ];then
			echo "${M}Hit ${C}<enter>${M} to continue, or  ${C}x + <enter>${M} to exit now if there is an error.${N}"
			read response
			case $response in
				x|X)
					error_handler 100 $FUNCNAME
					;;
			esac
		fi
	fi
	eval $LOGUE
}

# this is the hit enter to continue blurb...
print_hec()
{
	local response=''

	if [ "$AUTORUN" != 'true' ];then
		echo $MLINE
		# halt the script so people can read the advice
		echo "${Q}Please hit ${C}enter${Q} to continue${N}"
		echo $MLINE
		read response
	fi
}

### -------------------------------------------------------------------
### logging tools
### -------------------------------------------------------------------

create_log()
{
	local cardString=$( lspci | grep -i 'vga ' | cut -d ':' -f 3 )
	local sgfxiVersion=$( grep 'version:' $SCRIPT_NAME | grep -o "[0-9]*\.[0-9]*\.[0-9]*" )

	# check and create log file:
	if [ ! -d $LOG_FILE_DIR ];then
		mkdir $LOG_FILE_DIR
	fi
	# cleanup legacy logs
	rm -f ${LOG_FILE_DIR}200*-sgfxi.log
	# check and create logfile:
	LOG_FILE=$LOG_FILE_DIR$LOG_FILE

	if [ ! -f $SCRIPT_ROTATE ];then
		echo "$LOG_FILE {
	rotate 8
	create
	size 10k
}
" > $SCRIPT_ROTATE
	else
		# update if needed
		if [ -n "$( grep ' 120k' $SCRIPT_ROTATE )" ];then
			sed -i 's/rotate[[:space:]]4/rotate 8/' $SCRIPT_ROTATE
			sed -i 's/size[[:space:]]120k/size 10k/' $SCRIPT_ROTATE
		fi
	fi
	touch $LOG_FILE # make sure there's one there for rotate to look at
	if [ -n "$( which logrotate )" ];then
		logrotate $SCRIPT_ROTATE
	fi

	touch $LOG_FILE # and if rotated, need a new one
	echo "=========================================================" >> $LOG_FILE
	echo "START $SCRIPT_NAME LOGGING:" >> $LOG_FILE
	echo "=========================================================" >> $LOG_FILE
	echo "Script started: $( date +%Y-%m-%d-%H:%M:%S )" >> $LOG_FILE
	echo "Video Card Information:$cardString" >> $LOG_FILE
	echo "Video Card Type: $CARD_BRAND" >> $LOG_FILE
	echo "Video Card Number: $CARD_NUMBER" >> $LOG_FILE
	echo "Xorg Version: $X_VERSION" >> $LOG_FILE
	echo "Installing driver to kernel: $KERNEL_VERSION" >> $LOG_FILE
	if [ -n "$INSTALL_TO_KERNEL" ];then
		echo "Running install from Kernel: $(uname -r)" >> $LOG_FILE
	fi
	echo "$SCRIPT_NAME script version: $sgfxiVersion" >> $LOG_FILE
	echo "$SCRIPT_NAME start options: $START_OPTIONS" >> $LOG_FILE
	echo "SYSTEM_BASE: $SYSTEM_BASE" >> $LOG_FILE
	echo "SYSTEM_CODENAME: $SYSTEM_CODENAME" >> $LOG_FILE
	echo "DISTRIB_CODENAME: $DISTRIB_CODENAME" >> $LOG_FILE
	echo "DISTRIB_ID: $DISTRIB_ID" >> $LOG_FILE
	echo "DISTRIB_RELEASE: $DISTRIB_RELEASE" >> $LOG_FILE
	echo "FG_DISTRIB_CODENAME: $FG_DISTRIB_CODENAME" >> $LOG_FILE
	echo "FG_DISTRIB_ID: $FG_DISTRIB_ID" >> $LOG_FILE
	echo "APT_TYPE: $APT_TYPE" >> $LOG_FILE
	echo "=========================================================" >> $LOG_FILE
	# it's important to log these in case there's some issue or bug in the values
	if [ -f $SM_VALUES ];then
		echo -e "Begin User Set $SM_VALUES:\n$( cat $SM_VALUES)\nEnd User Set Values" >> $LOG_FILE
	fi
	echo -e "INSTALL_TO_KERNEL: $INSTALL_TO_KERNEL\nKERNEL_VERSION: $KERNEL_VERSION\nKERNEL_BASE: $KERNEL_BASE\nKERNEL_THREE: $KERNEL_THREE\nKERNEL_THIRD: $KERNEL_THIRD\nB_IS_XEN: $B_IS_XEN" >> $LOG_FILE

	B_LOGGING_STARTED='true'
}

# $1 type or data; $2 is function; $3 - function args, optional
log_function_data()
{
	local funcInfo='' logSpacer='  '

	if [ "$B_PRINT_VER" != 'true' ];then
		case $1 in
			ps)
				funcInfo="Function: $2 - Primary: Start"
				;;
			pe)
				funcInfo="Function: $2 - Primary: End"
				;;
			us)
				funcInfo="Function: $2 - Utility: Start"
				;;
			ue)
				funcInfo="Function: $2 - Utility: End"
				;;
		esac

		if [ -n "$funcInfo" ];then
			log_writer "$funcInfo"
		else
			log_writer "${logSpacer}$1"
		fi

		if [ -n "$3" ];then
			log_writer "${logSpacer}Args: $3"
		fi
	fi
}

log_driver_installer_failure()
{
	local nvidiaLog='/var/log/nvidia-installer.log'
	local atiLog='/usr/share/ati/fglrx- install.log'
	local errorLog=''
	
	case $CARD in
		$FGLRX)
			errorLog=$atiLog
			;;
		$NVIDIA)
			errorLog=$nvidiaLog
			;;
	esac
	echo $PLINE  >> $LOG_FILE
	echo "Error logs from $CARD install: $errorFileData" >> $LOG_FILE
	echo $PLINE  >> $LOG_FILE
	if [ -f "$errorLog" ];then
		cat $errorLog >> $LOG_FILE
	else
		echo "No error logs found from the run package installer!" >> $LOG_FILE
	fi
	echo $PLINE  >> $LOG_FILE
}

# args: $1 - data to write to logfile. Note that the function is always logged
# via function_logging first, and other relevant globals are set there as well
log_writer()
{
	# this handles first line indents, all other indents must be set in message data
	# like so: message="some problem... \n${LOG_INDENT}more problem stuff..."
	if [ "$B_LOGGING_STARTED" == 'true' ];then
		# strip out escape color code, if any. Method by dzz, thanks ;-)
		echo -e "$1" | sed 's/\x1b\[[0-9]\{1,2\}\(;[0-9]\{1,2\}\)\{0,2\}m//g' >> $LOG_FILE
	fi
}

########################################################################
#### FUNCTIONS: CORE GRAPHIC DRIVER INSTALLER TOOLS
########################################################################

### -------------------------------------------------------------------
### Native Driver installer section
### -------------------------------------------------------------------

# this bypasses core binary installers and just runs the required pieces
install_native_driver()
{
	eval $LOGPS
	local xorgBase='' xorgNv='nv' xorgAti='ati' xorgIntel='intel'
	local xorgDriver='' driver='' currentlyInstalled='' xorgCore=''
	local driverInstall='' experimentalText='' libMesaGlx=''
	local extraAtiPackage1='' bSkipInstall=''
	
	case $SYSTEM_BASE in
		debian|ubuntu)
			xorgBase='xserver-xorg-video-'
			xorgCore='xserver-xorg-core'
			libMesaGlx='libgl1-mesa-glx'
			;;
		arch)
			extraAtiPackage1="install_package 'ati-dri' '' 'reinstall'"
			xorgBase='xf86-video-'
			xorgCore='xorg-server'
			libMesaGlx='libgl'
			if [ "$NATIVE_OVERRIDE" == 'radeon' ];then
				NATIVE_OVERRIDE=$xorgAti
			fi
			;;
		fedora)
			xorgBase='xorg-x11-drv-'
			xorgCore='xorg-x11-server-Xorg'
			libMesaGlx='libMesaGlx=' # I think, check this: yum list *mesa*
			;;
	esac

	if [ "$B_EXPERIMENTAL" == 'true' ];then
		experimentalText=' experimental'
	fi
	#
	if [ "$B_DEFAULT_NATIVE_DRIVER" == 'true' -o -n "$NATIVE_OVERRIDE" ];then
		eval $LOGPS
		# assign defaults from earlier CARD assignments in -n
		xorgDriver=$CARD
		# then do special case handling
		case $CARD in
			$NVIDIA)
				xorgDriver=$xorgNv
				;;
			# note: use default ati here and only override to radeon/radeonhd for native override
			$FGLRX)
				xorgDriver=$xorgAti
				;;
			$INTEL)
				xorgDriver=$xorgIntel
				;;
		esac

		# driverInstall is just for output text for user to know what driver script installs
		driverInstall=$xorgDriver
		# replace with override if it's been set
		if [ -n "$NATIVE_OVERRIDE" ];then
			xorgDriver=$NATIVE_OVERRIDE
			driverInstall=$NATIVE_OVERRIDE
		fi
		# driver is the actual driver xorg will use
		driver=$xorgBase$xorgDriver
		
		if [ "$B_PRINT_VER" != 'true' ];then
			# make sure the driver is available for the user's debian version
			# is it true? nouveau pulled out of xorg? what the hell?
			if [ -z "$( check_package_status $driver 'c' )" ];then
# 				if [ "$NATIVE_OVERRIDE" != 'nouveau' ];then
					error_handler 222 "$driver"
# 				else
# 					bSkipInstall='true'
# 				fi
			fi
			print_information_continue 'standard' "The graphics installer will be installing the${C}$experimentalText Free xorg${S} driver: ${C}$driverInstall${N}"
		else
			exit 0 # this is required for smxi native driver tests
		fi
		x_start_stop_master stop

		## cleanup up old stuff
		pre_extract_clean_set_up
		preinstall_cleanup
		# this is required to do radeon xorg driver
		native_driver_install_keep
		if [ -n "$xorgCore" ];then
			# aptitude doesn't download missing package for reinstall
			case $SYSTEM_BASE in
				debian|ubuntu)
					install_package "$xorgCore" '' ''
					;;
			esac
			install_package "$xorgCore" '' 'reinstall'
		fi
		# need an override for this
		if [ "$CARD" == "$FGLRX" -a "$B_TESTING_5" != 'true' ];then
			install_package "$libMesaGlx" '' 'reinstall'
		fi
		
		if [ "$CARD" == "$FGLRX" -a "$B_EXPERIMENTAL" == 'true' ];then
			echo "${S}Installing experimental driver ${C}$driver${S} now...${N}"
			native_driver_experimental "$driver"
		else
			if [ "$bSkipInstall" != 'true' ];then
				# aptitude doesn't download missing package for reinstall
				case $SYSTEM_BASE in
					debian|ubuntu)
						install_package "$driver" '' ''
						;;
				esac
				install_package $driver '' 'reinstall'
			fi
			if [ "$CARD" == "$FGLRX" ];then
				eval $extraAtiPackage1
			fi
		fi
		# we'll need this to determine whether to do a reboot for radeon/nouveau
		NON_FREE_DRIVER=$( grep -Esi 'Driver[[:space:]]+"(fglrx|nvidia)"' $EXXC | grep -oEs "(nvidia|fglrx)" )
		## clean / update xorg, this is only to change driver to ati/nv, no full xorg conf yet.
		update_xorg
		process_xvmc # this will restore xvmc defaults if nvidia stuff was being used
		
		case $NATIVE_OVERRIDE in
			nouveau|radeon)
				case $SYSTEM_BASE in
					arch|fedora|debian|ubuntu)
						add_module "$NATIVE_OVERRIDE"
						;;
				esac
				set_modesetting_on $NATIVE_OVERRIDE
				;;
		esac

		eval $LOGPE
		## and finish it up
		x_start_stop_master start
		exit 0 # just exit here in case something weird goes wrong with xorg start
	else
		error_handler 254 # this is redundant, but I'm leaving it as a fail safe
	fi
	eval $LOGPE
}

native_driver_install_keep()
{
	eval $LOGUS
	local lgmd='libgl1-mesa-dri'  ldrm='libdrm2'

	if [ "$NATIVE_OVERRIDE" == 'radeon' ];then
		if [ -z "$( check_package_status "$lgmd" 'i' )" ];then
			install_package $lgmd
		fi
		if [ -z "$( check_package_status "$ldrm" 'i' )" ];then
			install_package $ldrm
		fi
		if [ -n "$( type -P deborphan )" ];then
			# doing one at a time because if one is already on keep,
			# trying to add both will fail
			deborphan --add-keep $lgmd > /dev/null
			deborphan --add-keep $ldrm > /dev/null
		fi
	fi
	eval $LOGUE
}

# args: $1 $driver; $2 $currentlyInstalled
native_driver_experimental()
{
	eval $LOGPS
	if [ "$CARD" == $FGLRX ];then
		# step one, check and install basic drivers
		if [ -n "$EXPERIMENTAL_XORG_ATI" ];then
			echo "${S}Starting experimental driver ${C}$1${S} install now...${N}"
			download_install_package freedesktop-ati
			unset packageExists
		else
			error_handler 187 exp-xorg-ati
		fi
		# step 2, if required, check and install extra packages
		if [ "$B_EXTRA_EXPERIMENTAL" == 'true' -a -n "$EXPERIMENTAL_LIBDRM2" ];then
			echo "${S}Adding experimental components for ${C}$1${S} now...${N}"
			download_install_package freedesktop-ati-drm2
			download_install_package freedesktop-ati-drm-dev
			unset packageExists
		else
			error_handler 187 exp-drm2
		fi
	fi
	eval $LOGPE
}

# this is for non-standard debs, and other stuff, for experimental use primarily
download_install_package()
{
	eval $LOGUS
	local packageToInstall='' url='' systemType='_i386.deb' shortPackage=''
	if [ "$BITS" == '64' ];then
		systemType='_amd64.deb'
	fi

	case $1 in
		freedesktop-ati)
			packageToInstall=$EXPERIMENTAL_XORG_ATI$systemType
			;;
		freedesktop-ati-drm2)
			packageToInstall=$EXPERIMENTAL_LIBDRM2$systemType
			;;
		freedesktop-ati-drm-dev)
			packageToInstall=$EXPERIMENTAL_LIBDRM_DEV$systemType
			;;
	esac
	
	url=$SCRIPT_DOWNLOAD'ati-drivers/'$packageToInstall
	if [ -z "$packageToInstall" ];then
		error_handler 187 download-package
	fi
	# slice out first part of name for package display purposes
	shortPackage=$( echo $packageToInstall | cut -d '_' -f 1 )

	echo "${S}Downloading Experimental package ${C}$shortPackage${S} now...${N}"
	wget -Nc $url || error_handler 189 $packageToInstall

	if [ -s "$packageToInstall" ];then
		echo "${S}Experimental package ${C}$shortPackage${S} downloaded successfully, installing now.${N}"
		dpkg -i $packageToInstall
		rm -f $packageToInstall
	else
		#rm -f $packageToInstall
		error_handler 188 $packageToInstall
	fi
	eval $LOGUE
}

prep_native_driver()
{
	eval $LOGUS
	local xxva='xserver-xorg-video-ati' ldrmd='libdrm-dev'
	local packageList=''

	case $CARD in
		$FGLRX)
			packageList="$xxva $ldrmd"
			;;
	esac
	eval $LOGUE
	remove_package "$packageList" "$xxva"
}

### -------------------------------------------------------------------
### KMS Tools - Modesetting On/Off, Blacklist On/Off, Initramfs set
### -------------------------------------------------------------------

# $1 - module to be handled; $2 - optional: failed (triggers reboot requirement)
set_modesetting_off()
{
	eval $LOGPE
	local bShowMessage='false'
	
	case $1 in
		nouveau|radeon)
			case $SYSTEM_BASE in
				arch)
					if [ "$2" == 'failed' ];then
						echo $LINE
						echo "${S}Please note: Arch users: you can proceed with your driver install, but you must ${S}reboot${S}"
						echo "at the end of ${C}$SCRIPT_NAME${S} when the install is completed before the driver will work."
						echo "This is because its not possible to remove ${C}$1${S} from a running system.${N}"
						print_hec
					fi
					;;
				*)
					# only act if blacklist/nomodeset was added
					add_grub_nomodeset_blacklist_item $1
					if [ "$?" -eq 0 ];then
						bShowMessage='true'
					fi
					add_modprobe_d_blacklist_item $1
					if [ "$?" -eq 0 ];then
						bShowMessage='true'
					fi
					if [ "$bShowMessage" == 'true' ];then
						update_initramfs "remove-$1"
					fi
					
					if [ "$bShowMessage" == 'true' -a "$2" == 'failed' ];then
						# note: we don't want nouveau to try to restart on reboot, so we're changing
						# xorg.conf to use vesa here.
						NATIVE_OVERRIDE='vesa'
						echo "${S}Setting ${C}$EXXC${S} to use ${C}Xorg vesa driver${S} temporarily..... ${N}"
						update_xorgconf_driver_version
						reboot_now_question "$1" 'modeset-off'
					fi
					;;
			esac
			;;
	esac
	eval $LOGPS
}

# $1 - module to be handled; $2 - optional: failed (triggers reboot requirement)
set_modesetting_on()
{
	eval $LOGPS
	local bShowMessage='false'

	case $1 in
		nouveau|radeon)
			# only act if blacklist/nomodeset was removed
			remove_grub_nomodeset_blacklist_item $1
			if [ "$?" -eq 0 ];then
				bShowMessage='true'
			fi
			remove_modprobe_d_blacklist_item $1
			if [ "$?" -eq 0 ];then
				bShowMessage='true'
			fi
			if [ "$bShowMessage" == 'true' ];then
				update_initramfs "add-$1"
			fi
			if [ "$bShowMessage" == 'true' -a "$2" == 'failed' ] || [ -n "$NON_FREE_DRIVER" ];then
				reboot_now_question "$1" 'modeset-on'
			fi
			;;
	esac
	eval $LOGPE
}

get_active_grub_files()
{
	eval $LOGUS
	local grubFiles=''
	
	if [ -f "$GRUB1_FED" ];then
		grubFiles="$GRUB1_FED"
	else
		if [ -f "$GRUB1" ];then
			grubFiles="$GRUB1"
		fi
		if [ -f "$GRUB2" ];then
			grubFiles="$grubFiles $GRUB2"
		fi
		if [ -f "$GRUBED" ];then
			grubFiles="$grubFiles $GRUBED"
		fi
	fi
	log_function_data "grub files: $grubFiles"
	
	if [ -z "$grubFiles" ];then
		error_handler 213 "modesetting-on-off"
	else
		echo $grubFiles
	fi
	eval $LOGUE
}

# args: $1 - radeon/nouveau
add_grub_nomodeset_blacklist_item()
{
	eval $LOGUS
	
	local returnValue=1 
	local noModesetString='nomodeset'
	local moduleSearch1="nomodeset|$1.modeset=0|rdblacklist=$1|$1.blacklist=1"
	local grubFiles=$( get_active_grub_files )

	case $SYSTEM_BASE in
		fedora)
			noModesetString="rdblacklist=$1"
			;;
	esac
	
	if [ -n "$grubFiles" ];then
		if [ -z "$( grep -Eis '('$moduleSearch1')' $grubFiles )" ];then
			echo -n "${S}Adding ${C}$grubFiles $noModesetString${S} for ${C}$1${S} blacklist${S} items..... ${N}"
			if [ -f "$GRUB1" -a -z "$( grep -Eis 'kernel.*root=.*('$moduleSearch1')' $GRUB1 )" ];then
				sed -i "/kernel.* root=/s|$| $noModesetString|" $GRUB1
			fi
			if [ -f "$GRUB1" -a -z "$( grep -Eis 'kopt.*root=.*('$moduleSearch1')' $GRUB1 )" ];then
				sed -i "/kopt.*root=/s|$| $noModesetString|" $GRUB1
			fi
			if [ -f "$GRUB2" -a -z "$( grep -Eis 'linux.*root=.*('$moduleSearch1')' $GRUB2 )" ];then
				sed -i "/linux.* root=/s|$| $noModesetString|" $GRUB2
			fi
			if [ -f "$GRUB1_FED" -a ! -f "$GRUB2" -a -z "$( grep -Eis 'kernel.*root=.*('$moduleSearch1')' $GRUB1_FED )" ];then
				sed -i "/kernel.* root=/s|$| $noModesetString|" $GRUB1_FED
			fi	
			log_function_data "file updated to add $1 nomodeset: $grubFiles"
			echo "${S}Added${N}"
			returnValue=0
		fi
	fi
	if [ -f "$GRUBED" ];then
		if [ -z "$( grep -Eis "^GRUB_CMDLINE_LINUX_DEFAULT=.*$moduleSearch1" $GRUBED )" ];then
			echo -n "${S}Adding ${C}$GRUBED nomodeset${S} for ${C}$1${S} blacklist${S} items..... ${N}"
			sed -r -i 's|GRUB_CMDLINE_LINUX_DEFAULT="(.*)"|GRUB_CMDLINE_LINUX_DEFAULT="\1 '$noModesetString'"|' $GRUBED
			echo "${S}Added${N}"
			log_function_data "file updated to add nouveau nomodeset: $GRUBED"
			returnValue=0
		fi
	fi
	case $SYSTEM_BASE in
		fedora)
			if [ -f "$GRUB1_FED" -a ! -f "$GRUB2" ];then
				if [ -z "$( grep -si 'vmalloc=' $GRUB1_FED )" ];then
					echo -n "${S}Adding ${C}$GRUB1_FED vmalloc=256m${S} item..... ${N}"
					sed -i '/kernel.* root=/s|$| vmalloc=256m|' $GRUB1_FED
					log_function_data "file updated to add vmalloc=256m: $GRUB1_FED"
					echo "${S}Added${N}"
				fi
				# also make system bootable to init 3 easily with grub, otherwise you can
				# literally not be able to access tty OR desktop in some cases
				if [ -n "$( grep -Eis '^[[:space:]]*(hiddenmenu|timeout=0)' $GRUB1_FED )" ];then
					echo -n "${S}Unhiding grub menu and adding ${C}timeout=3${S} to ${C}$GRUB1_FED${S}..... ${N}"
					sed -i 's|^[[:space:]]*hiddenmenu|#hiddenmenu|' $GRUB1_FED
					sed -i 's|^[[:space:]]*timeout=0|timeout=3|' $GRUB1_FED
					log_function_data "file updated to restore grub timeout/unhide menu: $GRUB1_FED"
					echo "${S}Modified${N}"
				fi
			fi
			;;
	esac
	
	eval $LOGUE
	return $returnValue
}

# args: $1 - radeon/nouveau
remove_grub_nomodeset_blacklist_item()
{
	eval $LOGUS

	local returnValue=1
	local searchReplace1="nomodeset|$1.modeset=0|rdblacklist=$1|$1.blacklist=1"
	local grubFiles=$( get_active_grub_files )
	
	if [ -n "$grubFiles" ];then
		if [ -n "$( grep -Eis '('$searchReplace1')' $grubFiles )" ];then
			echo -n "${S}Removing ${C}$grubFiles $1 blacklist${S} items..... ${N}"
			sed -ri 's/[[:space:]]s('$searchReplace1')//ig' $grubFiles
			log_function_data "file updated to remove $1 blacklist: $grubFiles"
			echo "${S}Removed${N}"
			returnValue=0
		fi
	fi
	
	eval $LOGUE
	return $returnValue
}

# args: $1 - nouveau/radeon
add_modprobe_d_blacklist_item()
{
	eval $LOGUS
	local empksb='/etc/modprobe.d/kms-sg-blacklist.conf'
	local returnValue=1
	
	if [ -d /etc/modprobe.d ];then
		if [ -z "$( grep -Es "^[[:space:]]*blacklist[[:space:]]+$1" /etc/modprobe.d/*.conf )" ];then
			echo "${S}Creating ${C}$empksb $1 blacklist${S} item...${N}"
			if [ -f $empksb ];then
				echo -e "blacklist $1" >> $empksb
			else
				echo -e "blacklist $1" > $empksb
			fi
			returnValue=0
			log_function_data "file updated to add $1 blacklist: $empksb"
		fi
	fi
	eval $LOGUE
	return $returnValue
}

# args: $1 - nouveau/radeon
remove_modprobe_d_blacklist_item()
{
	eval $LOGUS
	local returnValue=1
	
	if [ -d /etc/modprobe.d ];then
		if [ -n "$( grep -Es '^[[:space:]]*blacklist[[:space:]]+'$1'' /etc/modprobe.d/*.conf )" ];then
			echo "${S}Removed $1 blacklisting from /etc/modprobe.d/*.conf${N}"
			sed -i "s/^[[:space:]]*blacklist[[:space:]]\+$1//i" /etc/modprobe.d/*.conf 2>/dev/null
			returnValue=0
			log_function_data "$1 blacklist removed from /etc/modprobe.d/*.conf"
		fi
	fi
	eval $LOGUE
	return $returnValue
}

# 1 - add-nouveau|radeon/remove-nouveau|radeon; 
update_initramfs()
{
	eval $LOGPS
	local storedNouveau="/boot/initramfs-$KERNEL_VERSION-nouveau.img"
	local storedRadeon="/boot/initramfs-$KERNEL_VERSION-radeon.img"
	local startingInitram="/boot/initramfs-$KERNEL_VERSION.img"
	case $SYSTEM_BASE in
		debian|ubuntu)
			case $1 in
				remove-nouveau|remove-radeon)
					if [ -n "$( type -p update-initramfs )" ];then
						echo "${S}Running ${C}update-initramfs -u${S} to remove Nouveau from initrd... ${N}"
						update-initramfs -u -k $KERNEL_VERSION
					fi
					;;
			esac
			;;
		fedora)
			case $1 in
				remove-nouveau)
					if [ -n "$( type -p dracut )" ];then
						echo "${S}Updating ${C}initramfs${S} to get rid of ${C}nouveau${S} now...${N}"
						mv -f $startingInitram $storedNouveau
						dracut $startingInitram $KERNEL_VERSION
					fi
					;;
				remove-radeon)
					if [ -n "$( type -p dracut )" ];then
						echo "${S}Updating ${C}initramfs${S} to get rid of ${C}radeon${S} now...${N}"
						mv -f $startingInitram $storedRadeon
						dracut $startingInitram $KERNEL_VERSION
					fi
					;;
				add-nouveau)
					if [ -f "$storedNouveau" ];then
						echo "${S}Restoring ${C}initramfs${S} with ${C}nouveau${S} now...${N}"
						mv -f $storedNouveau $startingInitram 
					elif [ -n "$( type -p dracut )" ];then
						echo "${S}Building ${C}initramfs${S} with ${C}nouveau${S} now...${N}"
						dracut $startingInitram $KERNEL_VERSION
					fi
					;;
				add-radeon)
					if [ -f "$storedRadeon" ];then
						echo "${S}Restoring ${C}initramfs${S} with ${C}radeon${S} now...${N}"
						mv -f $storedRadeon $startingInitram 
					elif [ -n "$( type -p dracut )" ];then
						echo "${S}Building ${C}initramfs${S} with ${C}radeon${S} now...${N}"
						dracut $startingInitram $KERNEL_VERSION
					fi
					;;
			esac
			;;
	esac
	eval $LOGPE
}

# args: $1 - module; $2 - modeset-on/modeset-off
reboot_now_question()
{
	eval $LOGPS
	local opt='' options='' initText='' initLevel=''
	
	case $DISTRIB_ID in
		fedora|aptosid|sidux|mepis|antix)
			initLevel=3
			;;
		*)
			initLevel='no-init'
			;;
	esac
	
	case $initLevel in
		2|3|4)
			initText="(use init ${C}$initLevel${M} to start, or use ${C}$initLevel${M} at grub)"
			;;
		*)
			initText="(use ctrl+alt+F1 to enter console after reboot)"
			;;
	esac
	
	echo $MLINE
	if [ "$2" == 'modeset-off' ];then
		echo "${M}Since ${C}$1${M} is running in the kernel, you will need to restart your computer before"
		echo "your ${C}$CARD${M} install is completed, and you may need to reboot again if it errors out,"
		echo "then you can run ${C}$SCRIPT_NAME${M} again and it should work."
		echo
		echo "${S}For best results, select the ${C}shutdown${S} option, let the computer sit for a minute, then restart it."
		
		echo $MLINE
		echo "${S}Not everyone's systems are having problems getting rid of ${C}$1${S}, but to make the process"
		echo "more consistently safe and reliable this step seems to be a good idea. Once you reboot,"
		echo "the ${C}$1${S} module will not be loaded, and no conflicts or issues should occur."
		echo "You only need to do this one time, since after that the ${C}$1${S} module will not load"
	elif [ "$2" == 'modeset-on' ];then
		echo "${M}To make your new ${C}$1 Xorg / Kernel modules${S} fully functional, you will need to reboot first"
		echo
		echo "${W}The ${C}$1${W} drivers have very unreliable support for newer ${C}nVidia/ATI${W} cards!"
		echo 
		echo "${S}If your desktop fails to start properly after you reboot, you may need to do one of two things:"
		echo "1 - move your xorg.conf file to a temporary new file name, like: "
		echo "    ${C}mv /etc/X11/xorg.conf /etc/X11/xorg.conf-holder${S}"
		echo "    then restart your gdm/kdm/xdm/slim desktop login manager. If X then starts, you're fine."
		echo "2 - Add the grub kernel option: ${C}nomodeset${S}"
		echo "    at grub load, using the edit (e) method in grub, then boot with that. This will allow"
		echo "    you to at least run $SCRIPT_NAME to install the non-free driver."
	fi
	echo $MLINE
	echo "${M}Remember, to install ${C}$CARD${M} drivers, you'll need to run ${C}$SCRIPT_NAME${M} again."
	echo "after you have restarted $initText"
	echo $LINE
	echo "${C}1 - shutdown${S} - Shutdown, wait 30 seconds, then restart manually (${M}RECOMMENDED!${S}).${N}"
	echo "${C}2 - reboot${S} - Reboot. This may not let some data unload from your memory.${N}"
	echo "${C}3 - quit${S} - Exit script, do other things (then restart system to install nvidia).${N}"
	echo $LINE
	options="shutdown reboot quit"
	select opt in $options
	do
		case $opt in
			shutdown)
				echo "${S}Shutting down now...${N}"
				halt
				exit 0
				;;
			reboot)
				echo "${S}Rebooting now...${N}"
				reboot
				exit 0
				;;
			quit)
				echo "${S}Ok, remember you need to reboot before the $1 changes are live.${N}"
				exit 100 # need to exit with 100 to not trigger root pid kill in smxi
				;;
			*)
				echo "${W}Please select one of the options in the list, thank you.${N}"
				bRepeat='true'
				;;
		esac
		break
	done
	eval $LOGPE
	if [ "$bRepeat" == 'true' ];then
		reboot_now_question
	fi
}

### -------------------------------------------------------------------
### Non-free Driver installer section
### -------------------------------------------------------------------

set_cpu_data()
{
	eval $LOGUS
	case $CARD in
		$NVIDIA)
			if [ "$BITS" == '64' ];then
				KERNEL_ARCH='_64'
				NV_64_ARCH='_64'
			fi
			;;
		$FGLRX)
			# this is legacy, no longer needed but in case ati changes again leave it
			KERNEL_ARCH='i386' # default value
			if [ "$BITS" == '64' ];then
				KERNEL_ARCH='amd64'
			fi
			;;
	esac

	if [ "$B_PRINT_VER" != 'true' ];then
		log_function_data "BITS: $BITS - arch: $KERNEL_ARCH"
	fi
	eval $LOGUE
}

## test if the driver to be installed is in the list of supported drivers
## advanced tests occur in driver_support_tests, patches set in run_driver_patches
check_supported_driver()
{
	eval $LOGUS
	local isGood='' pattern='[0-9]{4}'
	local drivers="$DRIVER_DEFAULT:$VERSIONS:$DRIVER_TESTING:$OTHER_VERSIONS:$DRIVER_QUAD"

	if [ -n "$DRIVER_OVERRIDE" ];then
		isGood=$( echo $drivers | grep "$DRIVER_OVERRIDE" )
		if [ -z "$isGood" ];then
			error_handler 241 $DRIVER_OVERRIDE
		fi
	fi
	if [ "$1" == 'last-check' ];then
		isGood=$( echo $drivers | grep "$DRIVER_DEFAULT" )
		if [ -z "$isGood" ];then
			error_handler 240 $DRIVER_DEFAULT
		fi
	fi
	eval $LOGUE
}

set_driver_install_version()
{
	eval $LOGPS
	local response='' printDriver='' newKernelText='' betaDriverText=''
	local moduleOrInstall='installing'

	# I'm forcing special cases to override the defaults so the data
	# printed out will show what drivers are supported
	if [ -n "$DRIVER_INSTALL" ];then
		DRIVER_DEFAULT=$DRIVER_INSTALL
	fi

	# this is only for du output :: this has to go before assigning -o version number
	if [ "$B_PRINT_VER" == 'true' ];then
		# echo the basic list:
		if [ "$B_USE_DISTRO_DRIVER" != 'true' ];then
			echo $DRIVER_DEFAULT':'$VERSIONS
		else
			# note: because sometimes I'm turning off fglrx run install due to failure
			# that leaves only debian fglrx to install
			echo $DISTRO_FGLRX
		fi
		exit 0
	fi
	# need to puke and die here, not earlier because of print out 
	if [ -n "$INSTALL_TO_KERNEL" -a "$B_FGLRX_DIRECT" == 'true' -a "$CARD" == $FGLRX -a "$( uname -r )" != "$INSTALL_TO_KERNEL" ];then
		error_handler 219
	fi

	if [ -n "$DRIVER_OVERRIDE" ];then
		DRIVER_DEFAULT=$DRIVER_OVERRIDE
	fi
	# error_handler 246 $DRIVER_DEFAULT # for unsupported cards
	if [ "$B_USE_DISTRO_DRIVER" != 'true' ];then
		check_supported_driver last-check
	else
		case $CARD in
			$FGLRX)
				DRIVER_DEFAULT=$DISTRO_FGLRX
				;;
			$NVIDIA)
				DRIVER_DEFAULT=$DISTRO_NVIDIA
				;;
		esac
	fi

	if [ "$B_SM_INSTALL" != 'true' -a -n "$START_OPTIONS_PRINT" ];then
		print_information_continue 'info' "You are using the following options:\n$START_OPTIONS_PRINT"
	elif [ "$B_SM_INSTALL" == 'true' -a -n "$INSTALL_TO_KERNEL" ];then
		newKernelText="\n${S}onto the kernel: ${C}$INSTALL_TO_KERNEL${N}"
	fi
	# this is only true if use beta flag true and beta driver exists
	if [ "$B_USE_BETA" == 'true' ];then
		case $CARD in
			$NVIDIA)
				if [ "$B_BETA_EXISTS" == 'true' ];then
					betaDriverText="\n${M}This is the latest ${C}Nvidia Beta driver${M} for your card type.${N}\n"
				else
					betaDriverText="\n${M}There is ${C}no current beta driver${M} for your ${C}nVidia${M} card type.\n${S}Using the current ${C}stable driver${S} instead.${N}\n"
				fi
				;;
			$FGLRX)
				betaDriverText="\n${M}There is no ${C}beta fglrx driver${M} for your ${C}ATI${M} card.\n${S}Using the current ${C}stable driver${S} instead.${N}\n"
				;;
		esac
	fi
	if [ "$B_KERNEL_MODULE_ONLY" == 'true' ];then
		moduleOrInstall='building a module for'
	fi
	print_information_continue 'standard' "The graphics installer will be $moduleOrInstall the ${C}$CARD${S} driver: ${C}$DRIVER_DEFAULT${N}$betaDriverText$newKernelText"

	log_function_data "Installing this driver: $DRIVER_DEFAULT"

	eval $LOGPE
	# test for support
	driver_support_tests supported-driver
}

# args: $1 - which fix. Holds miscellaneous highly specific fixes, created as needed
misc_fixes()
{
	eval $LOGUS
	local outcome=''
	case $1 in
		nvidia-24-link)
			local headersDir="${USRS}linux-headers-$KERNEL_VERSION/include"
			# I don't know why the -e/f tests fail, I thought -e means exists at all...
			if [ -L "$headersDir/asm" -o -e "$headersDir/asm" ];then
				rm -f $headersDir/asm
			fi

			echo "${S}Creating symbolic link ${C}asm-x86 asm${S}...${N}"

			ln -sf $headersDir/asm-x86 $headersDir/asm || error_handler 233 "link -s asm-x86 asm"

			if [ ! -e $headersDir/asm-i386 -a "$BITS" == '32' ];then
				log_function_data "Creating soft link asm-x86 asm-i386 in $headersDir"
				echo "${S}Creating symbolic link ${C}asm-x86 asm-i386${S}...${N}"

				ln -s $headersDir/asm-x86 $headersDir/asm-i386 || error_handler 233 "link -s asm-x86 asm-i386"
				log_function_data "Link successfully created."
			else
				log_function_data "link asm-x86 asm-i386 in $headersDir already exists"
			fi
			;;
		linux-generated-patch)
			local generated1="${USRS}$KERNEL_VERSION/include/generated/" 
			local generated2="/lib/modules/$KERNEL_VERSION/build/include/generated/"
			outcome="$generated1 or $generated2 do not exist"
			if [ -d "$generated1" -o -d "$generated2" ];then
				echo 'true'
				outcome="$generated1 or $generated2 exist"
			fi
			log_function_data "outcome: $outcome"
			;;
		drm-2-x-test)
			local drmVersion=$( check_package_status 'libdrm2' 'i' )
			local isFixedVersion='' isLessThan=''
			# set to 0 if null to avoid math errors
			if [ -z "$drmVersion" ];then
				drmVersion=0
			fi
			# returns 0 for true/ 1 for false
			dpkg --compare-versions $drmVersion gt 2.4.10
			isFixedVersion=$?
			dpkg --compare-versions $drmVersion lt 2.4
			isLessThan=$?
			log_function_data "isFixedVersion: $isFixedVersion :: isLessThan: $isLessThan"
			if [ "$isFixedVersion" -ne 0 -a "$isLessThan" -ne 0 ];then
				error_handler '220' "$drmVersion"
			fi
			;;
	esac
	eval $LOGUE
}

set_download_info()
{
	eval $LOGPS
	local packageName='' downloadUrl='' response='' moduleTest=0

	case $CARD in
		$NVIDIA)
			# set the package name, .run is added to it when it's needed
			DRIVER_FILE="NVIDIA-Linux-x86$NV_64_ARCH-$DRIVER_DEFAULT$NV_PKG_NO"
			downloadUrl="$NVIDIA_DOWNLOAD_SITE/XFree86/Linux-x86$KERNEL_ARCH/$DRIVER_DEFAULT/"
			;;
		$FGLRX)
			# set driver package name
			# DRIVER_FILE="ati-driver-installer-$DRIVER_DEFAULT-$CPU"
			DRIVER_FILE="ati-driver-installer-$DRIVER_DEFAULT-x86.x86_64"
			# set download path
			downloadUrl='http://www2.ati.com/drivers/linux/'
			;;
	esac

	log_function_data "download url: $downloadUrl - driver file: $DRIVER_FILE"

	eval $LOGPE
	
	# absolute override
	if [ "$B_KERNEL_MODULE_ONLY" == 'true' ];then
		: # do nothing
	# otherwise if -f used, force install
	elif [ "$B_FORCE_OPTION" == 'true' ];then
		download_extract_driver $downloadUrl $DRIVER_FILE
	else
		case $CARD in
			$NVIDIA)
				# leaving in test flags in case something goes wrong in early tests
# 				if [ "$B_TESTING_5" == 'true' ];then
					test_module_build_ok 'return'
					moduleTest="$?"
					if [ "$moduleTest" -eq 0 ];then
						build_kernel_module_only 'build' 'silent'
					else
						echo $LINE
						echo "${S}Unable to rebuild module from previous driver install. Reinstalling driver instead.${N}"
						if [ -n "$DISPLAY" -a "$B_TESTING_2" != 'true' -a "$B_SKIP_X_TEST" != 'true' ];then
							echo "${W}Sorry, installing the ${C}nVidia${W} driver can't be done in ${C}X${W}.${N}"
							error_handler 250
						fi
						download_extract_driver $downloadUrl $DRIVER_FILE
					fi
# 				else
# 					download_extract_driver $downloadUrl $DRIVER_FILE
# 				fi
				;;
			$FGLRX)
				download_extract_driver $downloadUrl $DRIVER_FILE
				;;
		esac
	fi
}

# arg: $1 install package to remove
pre_extract_clean_set_up()
{
	eval $LOGUS
	# this is only made for binary run packge installs
	if [ -d "$SCRIPT_WORKING_DIR" ];then
		cd $SCRIPT_WORKING_DIR
	fi
	if [ "$B_NATIVE_DRIVER" != 'true' ];then
		rm -rf $1 # this removes nvidia install dir if present
	fi

	# clean up any old stuff that might be left from last install, fglrx stuff
	# note: with 8.35.x ati switched to a randomly generated directory name
	# using the format fgrlx-install.FRGDXE
	rm -rf $FG_WORKING_DIR* /tmp/fglrx*
	rm -f /etc/fglrxrc /etc/fglrxprofiles.csv fglrx*
	eval $LOGUE
}

# args: $1 download url; $2 package name
download_extract_driver()
{
	eval $LOGPS
	local runPackage=$2'.run' errorTemp='' atiRef=''

	# this was needed to avoid some test from ati... not needed anymore last I tried
	case $CARD in
		$FGLRX)
			atiRef='--referer=ati.com '
			;;
	esac
	pre_extract_clean_set_up $2 ## $2 will only apply to nvidia install dir removal
	
	# test for existing downloaded version, then download, error if download fails
	# have to keep it in a clean if to avoid error
	if [ ! -f $runPackage ];then
		echo "${S}Downloading ${C}$runPackage${S} from ${C}$1${S}...${N}"
		wget -Nc $atiRef$1$runPackage || error_handler 197 $runPackage
	else
		echo "${S}Using the previously downloaded installer package: ${C}$runPackage${N}"
	fi

	echo "${S}Extracting ${C}$runPackage${S}...${N}"
	case $CARD in
		$NVIDIA)
			# extract it, on error delete and call error handling
			bash ./$runPackage --extract-only 1>> $LOG_FILE 2>> $LOG_FILE
			errorTemp="$?"
			;;
		$FGLRX)
			# here we want to end up with a directory name like: fglrx-install-9-6 
			LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= bash ./$runPackage --extract $FG_WORKING_DIR-$DRIVER_DEFAULT 1>> $LOG_FILE 2>> $LOG_FILE
			errorTemp="$?"
			;;
	esac

	if [ "$errorTemp" -gt 0 -a "$B_TESTING_2" != 'true' ];then
		rm -f $runPackage
		error_handler 196 $runPackage
	fi

	eval $LOGPE
}

prep_install()
{
	eval $LOGPS
	local gccVersion=$( grep -Eio 'gcc[[:space:]]*version[[:space:]]*[4-6]\.[0-9]{1,2}' /proc/version | grep -Eo '[4-6]\.[0-9]{1,2}' )
	local gccPackage="gcc-$gccVersion"  
	local libMesaGlx='' ubgv='' bUpdateGcc='false'

	case $SYSTEM_BASE in
		arch)
			gccPackage='gcc'
			libMesaGlx='libgl'
			# -n "$gccVersion" -a 
			if [ -n "$gccVersion" -a -z "$( check_package_status "$gccPackage" 'i' | grep "$gccVersion" )" ];then
				bUpdateGcc='true'
			fi
			;;
		debian)
			libMesaGlx='libgl1-mesa-glx'
			;;
		ubuntu)
			libMesaGlx='libgl1-mesa-glx'
			;;
		fedora)
			gccPackage='gcc'
			if [ -n "$gccVersion" -a -z "$( check_package_status "$gccPackage" 'i' | grep "$gccVersion" )" ];then
				bUpdateGcc='true'
			fi
			;;
	esac
	ubgv="/usr/bin/$gccPackage"
	
	case $CARD in
		$FGLRX)
			if [ "$B_TESTING_5" != 'true' ];then
				install_package "$libMesaGlx" '' 'reinstall'
			fi
			;;
	esac
	
	# We now need to do active detection of fglrx-install directory name due to
	# silly random directory naming schema ati just started with 8.35.5
	# Note: you can set --extract $FG_WORKING_DIR to hard code this name

	echo "${S}Preparing driver install...${N}"

	if [ -f $EDV -a ! -f /etc/sidux-version -a ! -f /etc/aptosid-version ];then
		m-a -i prepare
	fi

	if [ -x "$ubgv" -a "$bUpdateGcc" != 'true' ];then
		export CC=$ubgv
	else
		# going to try to update gcc to kernel version first before error exit.
		if [ -n "$( check_package_status "$gccPackage" 'c' )" ];then
			install_package "$gccPackage"
			# this may not be needed, we'll see how it goes.
# 			if [ "$( check_package_status "g++-$gccVersion" 'c' )" ];then
# 				install_package "g++-$gccVersion"
# 			fi
			export CC=$ubgv
		else
			if [ "$SYSTEM_BASE" != 'fedora' ];then #for fedora dev only
				error_handler 230 "$ubgv"
			fi
		fi
	fi
	eval $LOGPE
}

set_install_directory()
{
	case $CARD in
		$NVIDIA)
			INSTALL_DIRECTORY=$DRIVER_FILE
			;;
		$FGLRX)
			INSTALL_DIRECTORY=$( ls | grep "$FG_WORKING_DIR" )
			;;
	esac
	cd $SCRIPT_WORKING_DIR/$INSTALL_DIRECTORY
	log_function_data "Function: set_install_directory - set to: $SCRIPT_WORKING_DIR/$INSTALL_DIRECTORY"
}

preinstall_cleanup()
{
	eval $LOGPS
	local oldNvidia='' divertedPackages='' installer='nvidia-installer' oldFglrx=''
	local fglrxUninstaller='/usr/share/ati/fglrx-uninstall.sh'

	echo "${S}Running preinstall cleanup...${N}"
	# this is not set as a path if native driver install
	if [ "$B_NATIVE_DRIVER" != 'true' ];then
		cd $SCRIPT_WORKING_DIR/$INSTALL_DIRECTORY
	fi
	# some legacy cleanup gunk, this can probably be dumped
	if [ -f /etc/modutils/1alsa ];then
		mv /lib/modules/extra/alsa /lib/modules/$KERNEL_VERSION/
		rm -f /etc/modutils/1alsa
		if [ -n "$( type -p depmod )" ];then
			depmod $KERNEL_VERSION -a
		fi
	fi
	log_function_data "nvidia.ko files: \n$( ls /lib/modules/*/kernel/drivers/video/nvidia.ko 2>/dev/null )"
	#rm -f /lib/modules/$KERNEL_VERSION/kernel/drivers/video/nvidia.ko 1>> $LOG_FILE 2>> $LOG_FILE
	# for real driver installs, we need to remove ALL the existing nvidia driver .ko files
	rm -f /lib/modules/*/kernel/drivers/video/nvidia.ko 1>> $LOG_FILE 2>> $LOG_FILE
	# this is legacy stuff, not currently present
	rm -f /lib/modules/*/volatile/nvidia.ko >/dev/null 1>> $LOG_FILE 2>> $LOG_FILE
	rm -f /usr/local/bin/nvidia-settings /usr/local/bin/nvidia-xconfig 1>> $LOG_FILE 2>> $LOG_FILE
	rm -f /tmp/.X0-lock

	## nvidia uninstallers, for systems where nvidia has been installed once at least
	# both files should be present in case of previous nvidia install
	if [ -x /usr/bin/$installer ];then
		log_function_data 'Using nvidia uninstaller: /usr/bin/'$installer
		/usr/bin/$installer --uninstall -s -N 1>> $LOG_FILE 2>> $LOG_FILE || installError="$?"
	elif [ -f /usr/lib/libnvidia-tls.so.1 ];then
		log_function_data 'Using local nvidia uninstaller'
		# some cases this will not be present, like to native ati/nv conversion
		if [ -f ./$installer ];then
			./$installer --uninstall -s -N 1>> $LOG_FILE 2>> $LOG_FILE || installError="$?"
		fi
	fi
	## NVIDIA removal...
	# double check, clean up anything left after uninstaller runs
	rm -f ${USRS}nvidia* 1>> $LOG_FILE 2>> $LOG_FILE
	rm -f ${SCRIPT_WORKING_DIR}/nvidia* 1>> $LOG_FILE 2>> $LOG_FILE
	rm -rf ${USRS}modules/nvidia* 1>> $LOG_FILE 2>> $LOG_FILE
	if [ -n "$installError" ];then
		error_handler 192 $installError
	fi

	## this is just to check after the above un-installer runs, this must be here or the
	## above packages won't be present, better to let nvidia handle uninstalling itself
	# also can clean out install-binary-gfx packages or nvidia-glx if present
	oldNvidia=$( list_installed_packages 'nvidia' '(modalias|libvdpau|nvidia-bl-dkms)' )
	if [ -n "$oldNvidia" ];then
		case $SYSTEM_BASE in
			# libgl will break the removal of nvidia, odd packaging decision, so need to reinstall it.
			# this is a weird way to handle the nvidia/libgl dependency, it's almost a loop if you
			# dont' use the --nodeps flag..
			arch)
				# "$B_USE_DISTRO_DRIVER" != 'true' -a 
				if [ -z "$( check_package_status 'libgl' 'i' )" ];then
					if [ -n "$( check_package_status 'libgl' 'c' )" ];then
						install_package 'libgl' '' '--nodeps'
						# redo list because nvidia-utils is removed
						oldNvidia=$( list_installed_packages 'nvidia' '(modalias|libvdpau)' )
					fi
				fi
				;;
		esac
		case $APT_TYPE in
			apt-get|aptitude)
				dpkg --purge $oldNvidia  1>> $LOG_FILE 2>> $LOG_FILE
				;;
			pacman|yum)
				remove_package "$oldNvidia" '' 'no-loop'
				;;
		esac
	fi
	# this might need more work to not remove if X failed to stop
	remove_module 'nvidia'
	if [ "$B_NATIVE_DRIVER" != 'true' -a "$CARD" == "$NVIDIA" ];then
		remove_module 'nouveau'
	fi
	## FGLRX removal...
	# this is for manually installed amdccle removal
	if [ -f /usr/local/bin/amdccle ];then
		rm -f /usr/local/bin/amdccle
	fi

	oldFglrx=$( list_installed_packages 'fglrx' 'modalias' )
	if [ -n "$oldFglrx" ];then
		case $APT_TYPE in
			apt-get|aptitude)
				dpkg --purge $oldFglrx 1>> $LOG_FILE 2>> $LOG_FILE
				;;
			pacman|yum)
				remove_package "$oldFglrx" '' 'no-loop'
				;;
		esac
	fi
	
	# this is present in some installs, debian etch default for instance
	case $SYSTEM_BASE in
		debian|ubuntu)
			GL='/usr/X11R6/lib/libGL.so.1.2'
			for package in $( dpkg-divert --list | grep "diversion of $GL" | cut -d ' ' -f 7 | grep -v -e fglrx-driver -e xorg-driver-fglrx )
			do
				dpkg-divert --package $package --remove $GL  1>> $LOG_FILE 2>> $LOG_FILE
			done
			;;
	esac
	# then confirm that it's truly not installed in case of manual direct install
	if [ -f "$fglrxUninstaller" ];then
		bash $fglrxUninstaller
	fi
	remove_module 'fglrx'
	clean_dkms 
	eval $LOGPE
}

## run patch module, then install
run_driver_installer()
{
	eval $LOGPS
	local installError=0 installerArgs='' nothing=''
	local xModPath='/usr/lib/xorg/modules'
	local xLibPath='/usr/lib'
	local installer='nvidia-installer'
	local distroId='' fglrxNumber='1'
	local distroCodeName=''

	# this was set in prep_install()
	cd $SCRIPT_WORKING_DIR/$INSTALL_DIRECTORY
	echo "${S}Running driver installer for ${C}$DRIVER_DEFAULT${S} (this might take a while)...${N}"

	log_function_data "driver: $DRIVER_DEFAULT"

	# run the card installers
	case $CARD in
		$NVIDIA)
			if [ -d $xModPath -a -d $xLibPath ];then
				# --x-library-path=$xLibPath
				installerArgs="-s -N --x-module-path=$xModPath --x-library-path=$xLibPath"
				
			else
				installerArgs="-s -N"
			fi
			if [ "$B_GUI_MODE" == 'true' ];then
				installerArgs="$installerArgs --no-x-check"
			fi
			# note: handles change from older /emul libs in Debian
			# http://www.nvnews.net/vbulletin/showthread.php?t=135332
			# note that lenny can be assumed to not need, this, so wait til squeeze stable
			if [ "$BITS" == '64' ];then
				# note: it appears that 256.xx changed something here for 64 bit paths, and
				# this is an attempt to fix that, not sure if it will work
				# http://forum.xbmc.org/showthread.php?t=57885
				case $SYSTEM_BASE in
					debian)
						if [ "$SYSTEM_CODENAME" == 'sid' -o "$SYSTEM_CODENAME" == 'testing' ];then
# 							installerArgs="$installerArgs --compat32-prefix= --compat32-libdir=  --compat32-chroot=/usr/lib32"
							installerArgs="$installerArgs --compat32-prefix=/usr --compat32-libdir=lib32  --compat32-chroot=/usr/lib32"
						fi
						;;
					ubuntu)
# 						installerArgs="$installerArgs --compat32-prefix= --compat32-libdir=  --compat32-chroot=/usr/lib32"
						installerArgs="$installerArgs --compat32-prefix=/usr --compat32-libdir=lib32  --compat32-chroot=/usr/lib32"
						;;
				esac
			fi
			
			installerArgs="$installerArgs -k $KERNEL_VERSION"
			# fresh arch installs may have the single file but no headers in /usr/src
			# note that this didn't work even though the target file existed
# 			if [ "$B_USE_DIRECT_KERNEL_HEADER" == 'true' ];then
# 				installerArgs="$installerArgs --kernel-source-path=$KERNEL_HEADER_DIRECT"
# 			fi
			./$installer $installerArgs 1>> $LOG_FILE 2>> $LOG_FILE || installError="$?"
			# reverting the patched stuff before anything else happens
			apply_module_patch post
			install_libvdpau
			# only do a final removal of nouveau if the install succeeded
# 			remove_module 'nouveau' 
			;;
		$FGLRX)
			distroId=$FG_DISTRIB_ID
			distroCodeName=$FG_DISTRIB_CODENAME
			installer='ati-installer.sh'
			if [ "$B_FGLRX_DIRECT" != 'true' ];then
				installerArgs="$DRIVER_DEFAULT --buildpkg $distroId/$distroCodeName"
				log_function_data "dist-id/dist-codename: $distroId/$distroCodeName"
				fglrxNumber='2'
			else
				echo $MLINE
				echo "${M}NOTE: When the ${C}FGLRX${M} direct installer runs, it will ask you a series of questions."
				echo "Simply hit ${C}<enter>${M} for each question the installer asks you, the defaults are good."
				echo "${M}If the first question asks you which driver method, type the number ${C}$fglrxNumber${M}"
				echo "and then hit ${C}<enter>${M}, then continue to the other questions."
				echo
				echo "${S}Hit ${C}<enter>${S} now to start the direct installer."
				echo $MLINE
				read nothing
				installerArgs="$DRIVER_DEFAULT --install"
				log_function_data "direct fglrx install - no debs: options: $installerArgs"
			fi

			# tell fglrx installer correct x version
	# 		if [ -n "$( echo $X_VERSION | grep -E '[1-2]\.[4-9]' )" ]
	# 		then
	# 			export XVERSION=$X_VERSION
	# 			export XTYPE='X.Org'
	# 		fi
			# note: there's a bug in fglrx that apparently will show no error return on failure
# 			LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= bash ./$installer $installerArgs 1>> $LOG_FILE 2>> $LOG_FILE
			# ati just made the installer interactive, so can't log the data for now...
			LC_ALL= LC_CTYPE= LC_MESSAGES= LANG= bash ./$installer $installerArgs 
			installError="$?"
			;;
	esac

	if [ "$installError" -gt 0 ];then
		log_driver_installer_failure
		error_handler 245 $installError
	fi
	case $CARD in
		$FGLRX)
			:
			;;
	esac
	eval $LOGPE
}

# nvidia new only
install_libvdpau()
{
	local libVdPau=''
	
	case $SYSTEM_BASE in
		arch)
# 			libVdPau='libvdpau'
			libVdPau=''
			;;
		# http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=558369
		# note: until the sid break for nvidia-libvdpau1/nvidia-libvdpau1-driver is fixed...
# 		debian)
# 			libVdPau='nvidia-libvdpau1-driver'
# 			;;
	esac
	
	if [ "$B_TESTING_5" != 'true' -a -n "$libVdPau" -a "$LEGACY_LEVEL" -gt 3 ];then
		if [ -z "$( check_package_status "$libVdPau" 'i' )" ];then
			if [ -n "$( check_package_status "$libVdPau" 'c' )" ];then
				install_package "$libVdPau"
			fi
		fi
	fi
}

post_installer_steps()
{
	eval $LOGPS
	local ema='/etc/modutils/aliases' oldFglrx=''

	echo "${S}Running post installer steps...${N}"

	cd $SCRIPT_WORKING_DIR

	rm -rf $INSTALL_DIRECTORY # remove the extracted driver install directory in /usr/src

	## this I think I will combine into one, just cleanup everything, that will handle
	## card brand changes more robustly, and leave less cruft in the system
	case $CARD in
		$NVIDIA)
			rm -f /etc/modutils/nvidia
			if [ -f $ema ];then
				perl -pi -e 's|.*char-major-195.*[\n]?||' $ema
				perl -pi -e 's|[\n]?$|\n|' $ema
				echo "alias char-major-195 nvidia" >> $ema
			fi
			;;
		$FGLRX)
			clean_up_fglrx_junk
			rm -f fglrx-installer_*.changes
			case $SYSTEM_BASE in
				arch)
					if [ -z "$( check_package_status 'mesa' 'i' )" ];then
						if [ -n "$( check_package_status 'mesa' 'c' )" ];then
							install_package 'mesa'
						fi
					fi
					;;
			esac
			;;
	esac
	eval $LOGPE
}

### -------------------------------------------------------------------
### module tools
### -------------------------------------------------------------------

# $1 - direct/build; $2 - silent [optional]
build_kernel_module_only()
{
	eval $LOGPS
	local installedDriver='' moduleResult=0 driverModule='' silent=' '
	local runPackage="$DRIVER_FILE.run"
	
	# double check that target kernel, or current one, has stuff in /lib/modules
	
	case $CARD in
		$NVIDIA)
			B_SKIP_INSTALL='true'
			remove_module 'nouveau'
			if [ "$1" == 'direct' ];then
				test_install_kernel_version
				test_module_build_ok 'error'
			fi
			if [ -z "$DISPLAY" -a "$B_KERNEL_MODULE_ONLY" != 'true' ];then
				x_start_stop_master stop
			fi
			echo $LINE
			echo "${S}Building kernel module ${C}$DRIVER_DEFAULT${S} for kernel ${C}$KERNEL_VERSION${S} now (can take a while)...${N}"
			if [ "$2" != 'silent' ];then
				bash $SCRIPT_WORKING_DIR/$runPackage $silent -N --kernel-name=$KERNEL_VERSION --kernel-module-only -a || moduleResult=$?
			else
				silent=' -s'
				bash $SCRIPT_WORKING_DIR/$runPackage $silent -N --kernel-name=$KERNEL_VERSION --kernel-module-only -a 1>> $LOG_FILE 2>> $LOG_FILE || moduleResult=$?
			fi
			if [ "$moduleResult" -ne 0 ];then
				log_driver_installer_failure
				error_handler 171 "$moduleResult"
			else
				echo "${S}Build of module ${C}$DRIVER_DEFAULT${S} for kernel ${C}$KERNEL_VERSION${S} was a success!"
				if [ "$B_KERNEL_MODULE_ONLY" == 'true' ];then
					echo "Script will exit now and you can do what you want, the module is working for that kernel.${N}"
					exit 0
				else
					x_start_stop_master start
				fi
			fi
			;;
		*)
			error_handler 173 
			;;
	esac
	
	eval $LOGPE
}

# $1 - error/return
test_module_build_ok()
{
	eval $LOGPS
	local runPackage="$DRIVER_FILE.run" returnValue=0 nvidiaPackages=''
	local libGlNvidia='' xorgNvidia='' logData=''
	echo $LINE
	echo "${S}Starting ${C}$NVIDIA module${S} build process checks for kernel: ${C}$KERNEL_VERSION${N}"
	echo -n "  ${S}Checking for driver run package ${C}$DRIVER_FILE${S}.... ${N}"
	if [ ! -f "$SCRIPT_WORKING_DIR/$runPackage" ];then
		echo "${W}NOT FOUND${N}"
		returnValue=1
		logData="No Driver Run Package: "
		if [ "$1" == 'error' ];then
			error_handler 175 "$runPackage"
		fi
	else
		echo "${S}File Exists${N}"
	fi
	if [ "$returnValue" -eq 0 ];then
		echo -n "  ${S}Checking for distribution ${C}nVidia${S} driver packages.... ${N}"
		nvidiaPackages=$( list_installed_packages 'nvidia' '(modalias|libvdpau)' )
		if [ -n "$nvidiaPackages" ];then
			echo "${W}PRESENT${N}"
			returnValue=2
			logData="${logData}Distro Nvidia Package: "
			if [ "$1" == 'error' ];then
				error_handler 174
			fi
		else
			echo "${S}None Detected${N}"
		fi
	fi
	if [ "$returnValue" -eq 0 ];then
		# really readlink /usr/lib/$( readlink /usr/lib/libGL.so )
		libGlNvidia=$( readlink /usr/lib/libGL.so.1 | grep -Eois '[0-9]{2,3}\.[0-9]{2,3}(\.[0-9]+)?' )
		echo -n "  ${S}Checking for installed ${C}nVidia${S} driver.... ${N}" 
		if [ -z "$libGlNvidia" ];then
			echo "${W}No $SCRIPT_NAME ${C}nVidia${W} Driver Detected${N}"
			returnValue=3
			logData="${logData}No Installed Nvidia: "
			if [ "$1" == 'error' ];then
				error_handler 169
			fi
		else
			echo "${S}Driver Installed${N}"
		fi
	fi
	if [ "$returnValue" -eq 0 ];then
		echo -n "  ${S}Checking installed driver ${C}$libGlNvidia${S} matches requested driver ${C}$DRIVER_DEFAULT${S}.... ${N}" 
		if [ "$libGlNvidia" != "$DRIVER_DEFAULT" ];then
			echo "${W}MISMATCH${N}"
			returnValue=4
			logData="${logData}Driver Mismatch $libGlNvidia/$DRIVER_DEFAULT: "
			if [ "$1" == 'error' ];then
				error_handler 172 "$installedDriver"
			fi
		else
			echo "${S}Drivers Match${N}"
		fi
	fi
	if [ "$returnValue" -eq 0 ];then
		echo -n "  ${S}Checking to make sure ${C}Xorg${S} has not been updated since last ${C}nVidia${S} install.... ${N}" 
		# this file belongs to xserver-xorg but is overwritten by nvidia, so if above test
		# is true and this is null, then xorg has been renewed
		xorgNvidia=$( readlink /usr/lib/xorg/modules/extensions/libglx.so | grep -Eois '[0-9]{2,3}\.[0-9]{2,3}(\.[0-9]+)?' )
		# installedDriver=$( bash $SCRIPT_WORKING_DIR/$runPackage -N --driver-info | grep -Eio 'version:[[:space:]]*[0-9\.]+' | grep -oE '[0-9\.]+' )
		if [ -z "$xorgNvidia" ];then
			echo "${C}Xorg${W} Updated${N}"
			returnValue=5
			logData="${logData}Xorg updated: "
			if [ "$1" == 'error' ];then
				error_handler 168
			fi
		else
			echo "${S}Xorg Not Updated${N}"
		fi
	fi
# 	echo "${S}Checking that installed driver is the same as the driver you are having" 
# 	echo -n "${C}$SCRIPT_NAME${S} build a kernel module for: ${C}$DRIVER_DEFAULT${S}.... ${N}"
# 	installedDriver=$( bash $SCRIPT_WORKING_DIR/$runPackage -N --driver-info | grep -Eio 'version:[[:space:]]*[0-9\.]+' | grep -oE '[0-9\.]+' )
# 	if [ "$installedDriver" != "$DRIVER_DEFAULT" ];then
# 		echo "${W}MISMATCH${N}"
# 		returnValue=1
# 		if [ "$1" == 'error' ];then
# 			error_handler 172 "$installedDriver"
# 		fi
# 	else
# 		echo "${S}Drivers Match${N}"
# 	fi
	if [ "$returnValue" -eq 0 ];then
		echo -n "  ${S}Checking for previous ${C}nVidia${S} driver module for ${C}$KERNEL_VERSION${S}.... ${N}"
		if [ -f "/lib/modules/$KERNEL_VERSION/kernel/drivers/video/nvidia.ko" ];then
			echo "${W}PRESENT${N}"
			returnValue=6
			logData="${logData}Nvidia module exists: "
			if [ "$1" == 'error' ];then
				error_handler 170
			fi
		else
			echo "${S}None Detected${N}"
		fi
	fi
	log_function_data "returnValue: $returnValue\nError Data: $logData"
	return "$returnValue"
	eval $LOGPE
}

install_modules_to_all_kernels()
{
	check_root
	local kernels=$(ls /lib/modules | grep -v "$( uname -r )" )
	local otherDriver='' kernel='' grubFile='' kernelInGrub='' kernelsConfirmed=''
	if [ -f "$GRUB2" ];then
		grubFile=$GRUB2
	elif [ -f "$GRUB1_FED" ];then
		grubFile=$GRUB1_FED
	elif  [ -f "$GRUB1" ];then
		grubFile=$GRUB1
	fi
	if [ -z "$grubFile" ];then
		error_handler 213 "kernel-module-installer"
	fi
	# this isn't a great test, but it's better than no test, and should avoid a lot of false
	# kernel ids
	case $SYSTEM_BASE in
		debian|ubuntu|fedora)
			echo $LINE
			echo "${S}Confirming full kernel list from ${C}/lib/modules${S}...${N}"
			# make sure the kernels are real, not fake as found in /lib/modules vmware added...
			for kernel in $kernels
			do
				echo -n "${S}Checking ${C}$kernel${S} in ${C}$grubFile${S}.... ${N}"
				kernelInGrub=$( grep -Eis "^[[:space:]]*(kernel|linux).*$kernel" $grubFile )
				if [ -n "$kernelInGrub" ];then
					echo "${M}Confirmed${N}"
					kernelsConfirmed="$kernelsConfirmed $kernel"
				else
					echo "${W}Invalid${N}"
				fi
			done
			;;
		arch)
			# arch has unreliable kernel naming, not following uname -r, ie: kernel26.img
			kernelsConfirmed=$kernels 
			;;
	esac
	if [ -n "$kernelsConfirmed" ];then
		# support other drivers being used if desired
		if [ -n "$DRIVER_OVERRIDE" ];then
			otherDriver=" -o $DRIVER_OVERRIDE"
		fi
		if [ "$B_USE_BETA" == 'true' ];then
			otherDriver=" -B"
		fi
		echo $LINE
		echo "${S}OK, installing modules to all confirmed kernels now...${N}"
		for i in $kernelsConfirmed
		do 
			sgfxi $otherDriver -R -A -k -K $i
		done
		echo $LINE
		echo "${S}Hey, did it work? Great! Bye for now.${N}"
	else
		echo "${S}No kernels found to create modules for. Exiting script now.${N}"
	fi
	exit 0
}

# note: for 
# args: $1 - which module; for nouveau used, post nvidia install with no errors
# use: $2 - nvidia-post - clean grub/module files of nouveau blacklists
remove_module()
{
	eval $LOGPS

	local outcome='unset' 

	if [ -n "$( lsmod | grep "^$1" )" ];then
		echo -n "${S}Removing module${C} $1${S}...... ${N}"
		modprobe -r $1 1>> $LOG_FILE 2>> $LOG_FILE 
		if [ "$?" -ne 0 ];then
			echo "${W}FAILED${N}"
			echo "${M}Error removing ${C}$1${M} module for pre-install cleanup operation."
			echo "Please investigate this further since it may make your $CARD driver install fail.${N}"
			outcome='failed' 
		else
			# working that if removal fails, module should not be removed, this might not be
			# correct though. Especially not for future nouveau, radeonhd, 
			if [ -f /etc/modules ];then
				perl -pi -e "s/^[[:space:]]*$1.*\n?//" /etc/modules
			fi
			echo "${S}Removed${N}"
			outcome='removed'
		fi
	fi
	log_function_data "operation outcome: $outcome"
	# going to run this for all cases, not just failure, maybe that will work better
	case $1 in
		nouveau|radeon)
			set_modesetting_off "$1" "$outcome"
			;;
	esac
# 	if [ "$outcome" == 'failed' ];then
# 		set_modesetting_off "$1"
# 	fi
	
	eval $LOGPE
}

# args: $1 - module to add or process
# do some extra processing here for nouveau
add_module()
{
	eval $LOGPS

	local outcome='unset' 
	
	echo -n "${S}Adding module${C} $1${S}...... ${N}"
	modprobe $1 1>> $LOG_FILE 2>> $LOG_FILE
	if [ "$?" -ne 0 ];then
		echo "${W}FAILED${N}"
		echo "${M}Error adding ${C}$1${M} module after installation."
		echo "Please investigate this further since it may make your $CARD driver install fail.${N}"
		outcome='failed'
	else
		if [ -z "$( grep "^$1" /etc/modules )" ];then
			echo "$1" >> /etc/modules
		fi
		echo "${S}Added${N}"
		outcome='added'
	fi
	log_function_data "operation outcome: $outcome"
	# going to run this for all cases, not just failure, maybe that will work better
	case $1 in
		nouveau|radeon)
			set_modesetting_on "$1" "$outcome"
			;;
	esac
# 	if [ "$outcome" == 'failed' ];then
# 		set_modesetting_on "$1"
# 	fi
	
	eval $LOGPE
}


# this should in theory all be gone but not necessarily in fact
# note that fglrx isn't working well here at all...
clean_dkms()
{
	eval $LOGPS
	local eddma='/etc/default/dmakms'
	if [ -d /var/lib/dkms/fglrx ];then
		log_function_data "fglrx dkms directories found and deleted"
		rm -rf /var/lib/dkms/fglrx 1>> $LOG_FILE 2>> $LOG_FILE
	fi
	if [ -d /var/lib/dkms/nvidia ];then
		log_function_data "nvidia dkms directories found and deleted"
		rm -rf /var/lib/dkms/nvidia 1>> $LOG_FILE 2>> $LOG_FILE
	fi
	# handle the dmakms stuff too if present
	if [ -f "$eddma" ];then
		if [ -n "$( grep -Esi '^[[:space:]]*nvidia-kernel-source' $eddma )" ];then
			log_function_data "nvidia dmakms entry found and commented out"
			sed -i 's/nvidia-kernel-source/#nvidia-kernel-source/' $eddma
		fi
		if [ -n "$( grep -Esi '^[[:space:]]*fglrx-kernel-source' $eddma )" ];then
			log_function_data "fglrx dmakms entry found and commented out"
			sed -i 's/fglrx-kernel-source/#fglrx-kernel-source/' $eddma
		fi
	fi
	eval $LOGPE
}

# arg: $1 - pre/post Undoing the patches in case the xen stuff is needed later
# as of 2.6.25-2, debian kernels are compiled with xen, which breaks nvidia currently
apply_module_patch()
{
	eval $LOGPS
	local lmkv="/lib/modules/$KERNEL_VERSION"

	# the debian sid nvidia drivers are now working fine with xen enabled sid kernels
	if [ "$B_USE_DISTRO_DRIVER" != 'true' ] && [ -d "$lmkv" -a "$B_IS_XEN" == 'true' ];then
		# patch source: http://blog.creonfx.com/linux/how-to-install-nvidia-driver-on-2625-2-debian-kernel-with-xen
		cd $lmkv
		case $1 in
			pre)
				echo "${S}Running pre-install module patches (this might take a while)...${N}"
				grep 'CONFIG_XEN' . -Rl 2> /dev/null | xargs -i sed -i -e 's/CONFIG_XEN/CONFIG_LUPO/g' {}
				export IGNORE_XEN_PRESENCE=1
				;;
			post)
				echo "${S}Reverting pre-install module patches (this might take a while)...${N}"
				grep 'CONFIG_LUPO' . -Rl 2> /dev/null | xargs -i sed -i -e 's/CONFIG_LUPO/CONFIG_XEN/g' {}
				;;
		esac
		cd $SCRIPT_WORKING_DIR/$INSTALL_DIRECTORY
	fi
	eval $LOGPE
}

### -------------------------------------------------------------------
### distro fglrx/nvidia driver installer
### -------------------------------------------------------------------

install_distro_drivers()
{
	eval $LOGPS
	local nvidiaGlx='' nvidiaSource='' nvidiaModal='' nvidiaUtils=''
	local akmodNvidia='' drvNvidia1='' drvNvidia2='' 

	clean_up_fglrx_junk

	case $CARD in
		$NVIDIA)
			case $SYSTEM_BASE in
				arch)
					# dependencies handle the rest of this
					case $LEGACY_LEVEL in
						1)	:
							# this has already been error handled.
							;;
						2)	nvidiaGlx="nvidia-$NV_AR_LEGACY_2"
							nvidiaUtils="nvidia-$NV_AR_LEGACY_2-utils"
							;;
						3)	nvidiaGlx="nvidia-$NV_AR_LEGACY_3"
							nvidiaUtils="nvidia-$NV_AR_LEGACY_3-utils"
							;;
						*)	nvidiaGlx="nvidia"
							nvidiaUtils="nvidia-utils"
							;;
					esac
					echo "${S}Installing ${C}$DISTRO_NVIDIA${S} components...${N}"
					install_package "$nvidiaGlx"
					# conflicts with libgl and removes it
# 					install_package "$nvidiaUtils"
					;;
				debian)
					case $LEGACY_LEVEL in
						1)	# nvidiaGlx='nvidia-glx-legacy'
							# nvidiaSource='nvidia-kernel-legacy-source'
							# if the two lines below don't work, comment them and uncomment the ones above
							nvidiaGlx="nvidia-glx-legacy-$NV_DEBIAN_LEGACY_1"
							nvidiaSource="nvidia-kernel-legacy-$NV_DEBIAN_LEGACY_1-source"
							;;
						2)	nvidiaGlx="nvidia-glx-legacy-$NV_DEBIAN_LEGACY_2"
							nvidiaSource="nvidia-kernel-legacy-$NV_DEBIAN_LEGACY_2-source"
							;;
						3)	nvidiaGlx="nvidia-glx-legacy-$NV_DEBIAN_LEGACY_3"
							nvidiaSource="nvidia-kernel-legacy-$NV_DEBIAN_LEGACY_2-source"
							;;
						*)	nvidiaGlx='nvidia-glx'
							nvidiaSource='nvidia-kernel-source'
							;;
					esac
					# start the install
					if [ "$LEGACY_LEVEL" -ne 0 ];then
						echo "${S}Installing ${C}$DISTRO_NVIDIA${S} components...${N}"
						install_package 'nvidia-kernel-common'
						install_package 'nvidia-settings'
						install_package "$nvidiaSource"
						echo "${S}Creating  ${C}$DISTRO_NVIDIA${S} kernel module for kernel ${C}$KERNEL_VERSION${S}...${N}"
						# m-a --text-mode --non-inter -f -l ${KERNEL_VERSION} a-i $nvidiaSource
						m-a update 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 184 $DISTRO_NVIDIA
						m-a prepare $nvidiaSource 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 185 $DISTRO_NVIDIA
						m-a clean $nvidiaSource 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 182 $DISTRO_NVIDIA
						m-a build -t -f -l $KERNEL_VERSION $nvidiaSource 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 194 $DISTRO_NVIDIA
						m-a install -t -f -l $KERNEL_VERSION $nvidiaSource 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 193 $DISTRO_NVIDIA
		
						#m-a prepare && m-a qa-i nvidia
						#nvidiaGlx has dependences problems. Workaround is to build-install the driver before install nvidiaglx
						echo "${S}Installing ${C}$nvidiaGlx${S} now...${N}"
						install_package "$nvidiaGlx"
						add_module 'nvidia'
					fi
					;;
				fedora)
					# dependencies handle the rest of this
					# kmod-nvidia xorg-x11-drv-nvidia-libs.i586 xorg-x11-drv-nvidia-libs.x86_64
					# kmod-nvidia-PAE xorg-x11-drv-nvidia-libs.i586 xorg-x11-drv-nvidia-libs.x86_64
					# akmod-nvidia-173xx xorg-x11-drv-nvidia-173xx-libs.i586 xorg-x11-drv-nvidia-173xx-libs.x86_64
					# akmod-nvidia-96xx xorg-x11-drv-nvidia-96xx-libs
					local archExt='i686' archExt64='x86_64' 
					if [ "$BITS" == '64' ];then
						archExt=$archExt64
					fi
					case $LEGACY_LEVEL in
						1)	:
							# this has already been error handled.
							;;
						2)	akmodNvidia="akmod-nvidia$NV_FED_LEGACY_2"
							drvNvidia1="xorg-x11-drv-nvidia$NV_FED_LEGACY_2-libs.$archExt"
							if [ "$BITS" == '64' ];then
								drvNvidia2="xorg-x11-drv-nvidia$NV_FED_LEGACY_2-libs.$archExt64"
							fi
							;;
						3)	akmodNvidia="akmod-nvidia$NV_FED_LEGACY_3"
							drvNvidia1="xorg-x11-drv-nvidia$NV_FED_LEGACY_3-libs.$archExt"
							if [ "$BITS" == '64' ];then
								drvNvidia2="xorg-x11-drv-nvidia$NV_FED_LEGACY_3-libs.$archExt64"
							fi
							;;
						*)	akmodNvidia="akmod-nvidia"
							drvNvidia1="xorg-x11-drv-nvidia-libs.$archExt"
							if [ "$BITS" == '64' ];then
								drvNvidia2="xorg-x11-drv-nvidia-libs.$archExt64"
							fi
							;;
					esac
					
					echo "${S}Installing ${C}$DISTRO_NVIDIA${S} components...${N}"
					install_package "$akmodNvidia $drvNvidia1 $drvNvidia2"
					# only do a final removal of nouveau if the install succeeded
# 					remove_module 'nouveau'
					
					if [ -x /usr/sbin/akmods ];then
						echo "${S}Forcing initial module build of ${C}$akmodNvidia${S} kernel module...${N}"
						/usr/sbin/akmods --force
					fi
					;;
				ubuntu)
					# dependencies handle the rest of this
					case $LEGACY_LEVEL in
						1)	:
							# this has already been error handled.
							;;
						2)	nvidiaGlx="nvidia-glx-$NV_UB_LEGACY_2"
							nvidiaModal="nvidia-$NV_UB_LEGACY_2-modaliases"
							;;
						3)	nvidiaGlx="nvidia-glx-$NV_UB_LEGACY_3"
							nvidiaModal="nvidia-$NV_UB_LEGACY_3-modaliases"
							;;
						*)	nvidiaGlx="nvidia-glx-$NV_UB_CURRENT"
							nvidiaModal="nvidia-$NV_UB_CURRENT-modaliases"
							;;
					esac
					echo "${S}Installing ${C}$DISTRO_NVIDIA${S} components...${N}"
					install_package "$nvidiaModal"
					install_package "$nvidiaGlx"
					;;
				*)
					error_handler 176
					;;
			esac 
			;;
		$FGLRX)
			case $SYSTEM_BASE in
				debian)
					echo "${S}Installing ${C}$DISTRO_FGLRX${S} components...${N}"
					install_package 'fglrx-driver'
					install_package 'fglrx-control'
					# install_package 'fglrx-amdcccle'
					install_package 'fglrx-kernel-src'
					echo "${S}Creating  ${C}$DISTRO_FGLRX${S} kernel module for kernel ${C}$KERNEL_VERSION${S}...${N}"
		
					# damentz suggestion to make sure old module is used
					# m-a a-i -f fglrx-kernel-src
					# kelmo:  m-a --text-mode --non-inter -f -l ${KERNEL_VERSION} a-i fglrx
					m-a update 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 184 $DISTRO_FGLRX
					m-a prepare fglrx 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 185 $DISTRO_FGLRX
					m-a clean fglrx 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 182 $DISTRO_FGLRX
					m-a build -f -l $KERNEL_VERSION fglrx 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 194 $DISTRO_FGLRX
					m-a install -f -l $KERNEL_VERSION fglrx 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 193 $DISTRO_FGLRX
					;;
				ubuntu)
					echo "${S}Installing ${C}$UBUNTU_FGLRX${S} components...${N}"
					install_package 'fglrx-modaliases'
					install_package 'xorg-driver-fglrx'
					;;
				*)
					error_handler 176
					;;
			esac
			;;
	esac
	eval $LOGPE
}

### -------------------------------------------------------------------
### ATI fglrx specific stuff
### -------------------------------------------------------------------

clean_up_fglrx_junk()
{
	eval $LOGUS
	# note that these can't be removed or 3d dies in direct -f install
	if [ "$B_FGLRX_DIRECT" != 'true' ];then
		rm -f /lib/modules/$KERNEL_VERSION/kernel/drivers/char/drm/fglrx.*o
		rm -f /lib/modules/$KERNEL_VERSION/volatile/fglrx.*o
		# this removes some config stuff that might cause watermarking issues
		# but this breaks direct install systems so don't remove it in direct install
		rm -rf /etc/ati
	fi

	if [ -d /usr/lib/opengl ];then
		rm -rf /usr/lib/opengl
		ldconfig
		log_function_data 'Note: cleanup usr/lib/opengl'
	fi

	eval $LOGUE
}

# this is only for fgrlx
install_fglrx_debs()
{
	# ati change this syntax too much... hope they stabilize
	# fglrx-amdcccle_8.443.1-1_i386.deb
	# fglrx-driver_8.443.1-1_i386.deb
	# fglrx-driver-dev_8.443.1-1_i386.deb
	# fglrx-installer_8.443.1-1_i386.changes
	# fglrx-kernel-src_8.443.1-1_i386.deb
	if [ "$CARD" == $FGLRX ];then
		eval $LOGPS
		local fgAmd='fglrx-amdcccle_' 
		local fgDri='fglrx-driver_' 
		local fgKsc='fglrx-kernel-src_'
		local fgDriver="$fgDri$DRIVER_DEFAULT-1_*.deb"
		local fgKsrc='fglrx-kernel-src'
		local fgAmdcccle="$fgAmd$DRIVER_DEFAULT-1_*.deb"
		local fgKernelSrc="$fgKsc$DRIVER_DEFAULT-1_*.deb"
		local fgAlias='' libAmdXv=''
		
		case $SYSTEM_BASE in
			ubuntu)
				fgDri='xorg-driver-fglrx_'
				fgKsc='fglrx-kernel-source_'
				fgKsrc='fglrx-kernel-source'
				fgDriver="$fgDri*.deb"
				fgAmdcccle="$fgAmd*.deb"
				fgKernelSrc="$fgKsc*.deb"
				libAmdXv='libamdxvb*.deb'
				fgAlias='fglrx-modaliases_*.deb'
				;;
		esac
		
		local availableDebs=$( ls *fglrx*.deb )
		local usunf='/usr/sbin/unfreeze-rc.d' 
		local frozen=0 forceIt=''
		
		case $SYSTEM_BASE in
			ubuntu)
				if [ -z "$( check_package_status 'dkms' 'i' )" ];then
					if [ -n "$( check_package_status 'dkms' 'c' )" ];then
						install_package 'dkms'
					fi
				fi
				;;
		esac

		# this is slightly excessive, but may handle a case where extra debs exist
		# due to weird user action. Also protects against new ati randomness.
		if [ -f $fgDriver ];then
			:
		elif [ -f $fgDri*.deb ];then
			fgDriver=$( ls $fgDri*.deb )
		else
			error_handler 186 $fgDri
		fi

		if [ -f $fgKernelSrc ];then
			:
		elif [ -f $fgKsc*.deb ];then
			fgKernelSrc=$( ls $fgKsc*.deb )
		else
			error_handler 186 $fgKsc
		fi

		if [ -f $fgAmdcccle ];then
			:
		elif [ -f $fgAmd*.deb ];then
			fgAmdcccle=$( ls $fgAmd*.deb )
		else
			error_handler 186 $fgAmd
		fi

# 		if [ "$SYSTEM_CODENAME" != 'unstable' ];then
# 			forceIt='--force-overwrite'
# 		fi
		if [ "$B_TESTING_5" == 'true' ];then
			forceIt='--force-all'
		fi

		log_function_data "These installation debs have been created: $availableDebs"

		echo "${S}Installing fglrx debs for kernel ${C}$KERNEL_VERSION${S}...${N}"
		# unfreeze/freeze stuff may be required for some legacy type systems
		if [ -f /etc/frozen-rc.d ];then
			frozen=1
		fi
		if [ -x $usunf ];then
			$usunf
		fi

		log_function_data "Actual driver packages to install:\nfgDriver: $fgDriver\nfgAmdcccle: $fgAmdcccle\nfgKernelSrc: $fgKernelSrc"

		# due to problems with config file questions, trying no logging of 1>> now
		dpkg -i $forceIt $fgKernelSrc 2>> $LOG_FILE || error_handler 195 $fgKernelSrc
		dpkg -i $forceIt $fgDriver 2>> $LOG_FILE || error_handler 195 $fgDriver
 		dpkg -i $forceIt $fgAmdcccle 2>> $LOG_FILE || error_handler 195 $fgAmdcccle
 		
 		case $SYSTEM_BASE in
 			ubuntu)
				if [ -n "$libAmdXv" ];then
					dpkg -i $forceIt $libAmdXv 2>> $LOG_FILE || error_handler 195 $libAmdXv
				else
					echo "${E}ERROR: Missing ${C}$libAmdXv${E} but continuing...${N}"
				fi
				if [ -n "$fgAlias" ];then
					dpkg -i $forceIt $fgAlias 2>> $LOG_FILE || error_handler 195 $libAmdXv
				else
					echo "${E}ERROR: Missing ${C}$fgAlias${E} but continuing...${N}"
				fi
				;;
 			debian)
				log_function_data "Done installing debs created, now to: m-a build  -l $KERNEL_VERSION -f $fgKsrc:"
				CC=$CC m-a build  -l $KERNEL_VERSION -f $fgKsrc 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 194 $fgKsrc
				log_function_data "Now to: m-a install  -l $KERNEL_VERSION -f $fgKsrc:"
				m-a install -l $KERNEL_VERSION -f $fgKsrc 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 193 $fgKsrc
				
				# note: note with dkms
			:
# 			log_function_data "Done installing debs created, now to: m-a build fglrx:"
# 			CC=$CC m-a build fglrx-kernel 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 194 fglrx-kernel
# 			log_function_data "Now to: m-a install fglrx:"
# 			m-a install fglrx-kernel 1>> $LOG_FILE 2>> $LOG_FILE || error_handler 193 fglrx-kernel
				;;
		esac

		# restore freeze state
		if [ "$frozen" -eq 1 -a -x $usunf ];then
			$usunf
		fi
		case $SYSTEM_BASE in
			debian)
				# put packages on hold fglrx-amdcccle, fglrx-driver, fglrx module
				echo "${S}Placing ATI packages on hold to avoid dist-upgrade issues with Debian fglrx drivers...${N}"
				hold_package 'fglrx-control'
				hold_package 'fglrx-driver'
				;;
			ubuntu)
				echo "${S}Placing ATI packages on hold to avoid upgrade issues with $DISTRIB_ID fglrx drivers...${N}"
				hold_package 'fglrx-amdcccle'
				hold_package 'xorg-driver-fglrx'
				;;
		esac

		eval $LOGPE
	fi
}

### -------------------------------------------------------------------
### Finalizing steps
### -------------------------------------------------------------------

# this only runs for non free driver installs, so no need to check for xorg stuff
final_install_steps()
{
	eval $LOGPS
	local fgModules='' fgModule=''

	echo "${S}Finalizing install...${N}"
	process_xvmc
	depmod $KERNEL_VERSION -a # Probe all modules

	case $CARD in
		$NVIDIA)
			# this needs to be cleaned up a bit
			mkdir -p /etc/udev/rules.d
			rm -f /etc/udev/nvidia.rules /etc/udev/rules.d/nvidia.rules
			ldconfig # Configure Dynamic Linker Run Time Bindings.
# 			remove_module 'nouveau'
			;;
		$FGLRX)
			##  clean up install parts
			rm -rf ${USRS}modules/fglrx
			rm -rf /tmp/fglrx* fglrx*
			add_module 'fglrx'
			# note, since ubuntu uses dkms we don't want to purge the kernel source
			case $SYSTEM_BASE in
				arch)
					fgModules='radeon drm'
					;;
				debian)
					dpkg --purge fglrx-kernel-src 1>> $LOG_FILE 2>> $LOG_FILE
					fgModules='radeon drm'
					;;
				ubuntu)
					fgModules='radeon drm'
					;;
			esac
			# test for, then remove if present
			for fgModule in $fgModules
			do
				remove_module "$fgModule"
			done
			;;
	esac

	sync # Force changed blocks to disk, update the super block
	echo $MLINE
	echo "${S}Congratulations! It looks like your new ${C}$DRIVER_DEFAULT $CARD${S} driver installed successfully!${N}"
	eval $LOGPE
}

process_xvmc()
{
	eval $LOGUS
	local lxvmcN='libXvMCNVIDIA_dynamic.so.1' lxvmc='libXvMC.so.1' exxv='/etc/X11/XvMCConfig'

	# xvmc information here: http://www.mythtv.org/wiki/index.php/XvMC
	if [ "$B_USE_XVMC" == 'true' -a "$B_NO_XVMC" != 'true' -a -x /usr/lib/$lxvmcN ];then
		echo $lxvmcN > $exxv
	else
		echo $lxvmc > $exxv
	fi
	eval $LOGUE
}

########################################################################
#### FUNCTIONS: XORG TOOLS
########################################################################

### -------------------------------------------------------------------
### Stop / Start Xorg handling section
### -------------------------------------------------------------------

x_start_stop_master()
{
	eval $LOGPS
	case $1 in
		stop)
			if [ "$B_SKIP_FUNCTION" != 'true' -a "$B_SM_INSTALL" != 'true' -a "$B_SKIP_X_TEST" != 'true' -a "$B_AUTORUN" != 'true' ];then
				start_stop_x stop
			fi
			;;
		start)
			if [ "$B_AUTORUN" != 'true' ];then
				if [ "$B_SKIP_X_QUESTION" == 'true' ];then
					start_stop_x start
				else
					# no point in starting x unless required
					if [ -z "$DISPLAY" ];then
						start_x_question
					# handles case where sgfxi is run in X
					else
						# almost no cases will X be running except a module build to another
						# kernel, since driver install shuts down X. Maybe distro-driver can do this.
						if [ -n "$INSTALL_TO_KERNEL" -a "$INSTALL_TO_KERNEL" != "$( uname -r )" ];then
							echo "${S}All done with driver install. Remember, you have to reboot to kernel ${C}$INSTALL_TO_KERNEL${S}"
							echo "for the driver module you just updated to be active.${N}"
						else
							echo "${S}All done with driver install. Remember, you have to restart X (your desktop)"
							echo "before your new driver is active.${N}"
						fi
					fi
				fi
			fi
			;;
	esac
	eval $LOGPE
}

start_x_question()
{
	eval $LOGPS
	local opt='' options='' bRepeat='false' package=''
	local ia32libs='ia32-libs' iaOpt='install-ia32libs'
	local ia32Alert='echo -e "\n${M}You should probably (re)install ${C}$ia32libs${M} (even if already installed)\nif you use applications that depend on them in your ${C}64 bit${M} system,\nfor example ${C}Wine${M}.${N}"'
	local ia32Install='echo -e "${C}$iaOpt${M} - Install ${C}$ia32libs${M} libs."'
	local fgGlxOpt='' fgGlx='' fgGlxAlert='' fgGlxInstall=''
	local startXopt='' startXText='' rebootOpt='' rebootText=''

	case $BITS in
		32)
			ia32Alert=''
			ia32Install=''
			iaOpt=''
			;;
		64)
			case $CARD in
				$FGLRX)
					fgGlxOpt='install-fglrx-glx'
					fgGlx='fglrx-glx fglrx-glx-ia32'
					fgGlxAlert='echo -e "\n${M}You might want to (re)install ${C}$fgGlx${M} (even if already installed)\nif you have problems with your ${C}64 bit ATI/fglrx${M} driver/apps.${N}"'
					fgGlxInstall='echo -e "${C}$fgGlxOpt${M} - Install ${C}$fgGlx${M}."'
					;;
				$NVIDIA)
					:
					;;
			esac
			;;
	esac
	ia32Alert=''
	ia32Install=''
	iaOpt=''
	fgGlx=''
	fgGlxOpt=''
	fgGlxAlert=''
	fgGlxInstall=''
	
	if [ "$B_SKIP_INSTALL" == 'true' -o -z "$INSTALL_TO_KERNEL" -o "$INSTALL_TO_KERNEL" == "$( uname -r )" ];then
		startXopt='start-desktop' 
		startXText='echo -e "${C}$startXopt${M} - All finished, (re-)start desktop now."'
	fi
	if [ -n "$INSTALL_TO_KERNEL" -a "$INSTALL_TO_KERNEL" != "$( uname -r )" ];then
		rebootOpt='reboot-now'
		rebootText='echo -e "${C}$rebootOpt${M} - You must reboot to use the driver for ${C}$INSTALL_TO_KERNEL${M}."'
	fi

	echo $MLINE
	echo "${S}Your driver install is now finished. You have the following options:"
	eval $ia32Alert
	eval $fgGlxAlert
	echo $LINE
	eval $ia32Install
	eval $fgGlxInstall
	eval $startXText
	eval $rebootText
	echo "${C}quit${M} - Quit now, to do something else before starting your desktop.${N}"
	echo $LINE
	options="$iaOpt $fgGlxOpt $startXopt $rebootOpt quit"
	select opt in $options
	do
		case $opt in
			install-ia32libs)
				if [ "$BITS" == '64' ];then
					echo "${S}Installing the package ${C}$ia32libs${S} now...${N}"
					install_package $ia32libs '' 'reinstall'
					log_function_data "Final Step: Installed: $ia32libs"
				else
					echo "${E}The package ${C}$ia32libs${E} is only available for ${C}64 bit${E} systems.${N}"
				fi

				# repeat the question for users so they can start x now if they want.
				bRepeat='true'
				;;
			install-fglrx-glx)
				if [ "$BITS" == '64' -a "$CARD" == $FGLRX ];then
					echo "${S}Installing packages ${C}$fgGlx${S} now...${N}"
					for package in $fgGlx
					do
						install_package $package '' 'reinstall'
					done

					log_function_data "Final Step: Installed: $fgGlx"
				else
					echo "${E}The packages ${C}$fgGlx${E} are only installable in ${C}64 bit + ATI fglrx${E} systems.${N}"
				fi
				# repeat the question for users so they can start x now if they want.
				bRepeat='true'
				;;
			start-desktop)
				echo "${S}Ok, starting your desktop now, thanks for using this script.${N}"
				log_function_data "Final Step: start-desktop"
				start_stop_x start
				;;
			reboot-now)
				echo "${S}Ok, rebooting into kernel ${C}$INSTALL_TO_KERNEL${S} and your"
				echo "${C}$DRIVER_DEFAULT${S} video driver. Thanks for using this script.${N}"
				log_function_data "Final Step: reboot to kernel: $INSTALL_TO_KERNEL"
				reboot
				exit 100 # need to exit with 100 to not trigger root pid kill in smxi
				;;
			quit)
				echo "${S}Ok, exiting now, thanks for using this script.${N}"
				# this is to send calling script message that it should not do its success action
				log_function_data "Final Step: quit"
				exit 100 # need to exit with 100 to not trigger pid root kill in smxi
				;;
			*)
				echo "${W}Please select one of the options in the list, thank you.${N}"
				bRepeat='true'
				;;
		esac
		break
	done

	if [ "$bRepeat" == 'true' ];then
		start_x_question
	fi
	eval $LOGPE
}
# start_x_question

# takes one argument, stop or start
start_stop_x()
{
	eval $LOGUS
	local displayManagers='entrance gdm kdm slim wdm xdm' dman='' success=''
	# setting the default will handle cases like default 2 while still handling 3/5
	# also note, future systems will probably not use inittab, ubuntu doesn't, but
	# they will read it, so we'll always use this as default to respect user changes
	local defaultRunlevel=$( grep -Es '^id.*:initdefault:' /etc/inittab | grep -Eo '[0-5]' )
	# default, this prevents errors when these don't exist in for ex. fedora
	local serviceControl='/etc/init.d/' startPath='/etc/init.d/' bSkipXKill='false'
	local noHup='nohup' xActionString='' finalXKill='' dmanCommand=''
	local gdmCommand='' bSkipLoop='false' dManager=$DISPLAY_MANAGER
	
	if [ -z "$DISPLAY" -a "$1" == 'stop' ];then
		noHup=''
	fi
	# note that init.d does not take a space, but service does,for the first parameter like kdm
	if [ -n "$( type -P service )" ];then
		serviceControl='service '
	fi
	case $SYSTEM_BASE in
		arch)
			serviceControl='/etc/rc.d/'
			bSkipXKill='true' # STARTS X when you KILL X...
			startPath='/etc/rc.d/'
			;;
		fedora) 
			serviceControl='' # no /etc/init.d, it's in /usr/sbin
			bSkipLoop='true'
			bSkipXKill='true' # STARTS X when you KILL X...
			case $1 in
				start)
					success='true' # go straight to init 5 start up
					;;
				stop)
					gdmCommand='init 3'
					;;
			esac
			dManager='gdm'
			;;
	esac
	log_function_data "default runlevel: $defaultRunlevel"
	## restart x if this is not being run by smxi
	if [ -z "$DISPLAY_MANAGER" -a "$bSkipLoop" != 'true' ];then
		for dman in $displayManagers
		do
			# arch, debian, ubuntu
			if [ -x $startPath$dman  ];then
				dmanCommand="$serviceControl$dman $1"
			else
				dmanCommand=''
			fi
			log_function_data "dmanCommand: $dmanCommand"
			if [ -n "$dmanCommand" ];then
				# nohup is required to make sure dm is fully stopped, and pids removed
				echo "${S}Attempting to ${C}$1${S} display manager ${C}$dman${S} now... ${N}"
				xActionString="$noHup $dmanCommand 2>/dev/null && success='true'"
				eval $xActionString
				if [ -z "$noHup" ];then
					if [ "$success" == 'true' ];then
						echo "${S}Display manager ${C}$1${S} sucessful.${N}"
					else
						echo "${W}Display manager ${C}$1${S} failed${N}"
					fi
				fi
			fi
		done
	else
		# have to retest dm for null for fedora here
		if [ -x $startPath$DISPLAY_MANAGER -a -n "$DISPLAY_MANAGER" ];then
			dmanCommand="$serviceControl$DISPLAY_MANAGER $1"
		elif [ -n "$gdmCommand" ];then
			dmanCommand=$gdmCommand # init 3 for fedora
		else
			dmanCommand=''
		fi
		log_function_data "dmanCommand: $dmanCommand"
		if [ -n "$dmanCommand" ];then
			# I tried stringing these in a && sequence but something failed and
			# init 5 start broke. This order takes care of runlevel restart bug
			# nohup is required to make sure dm is fully stopped, and pids removed
			echo "${S}Attempting to ${C}$1${S} default display manager ${C}$dManager${S} now... ${N}"
			xActionString="$noHup $dmanCommand && success='true'"
			eval $xActionString
			if [ -z "$noHup" ];then
				if [ "$success" == 'true' ];then
					echo "${S}Display manager ${C}$1${S} successful.${N}"
				else
					echo "${W}Display manager ${C}$1${W} failed.${N}"
				fi
			fi
		fi
	fi
	# this handles cases where somehow X is still running
	# startx x starts can for example bypass kdm tests, etc
	if [ "$1" == 'stop' ];then
		if [ "$( x_is_running )" -eq 0 -a "$bSkipXKill" != 'true' ];then
			echo "${M}Note: display manager shutdown failed... shutting down X directly instead... ${N}"
			xActionString="$noHup killall Xorg && finalXKill='true'"
			eval $xActionString
			if [ -z "$noHup" ];then
				if [ "$finalXKill" == 'true' ];then
					echo "${S}X shutdown successful.${N}"
				else
					echo "${W}X shutdown failed.${N}"
				fi
			fi
		fi
	fi
	# this will exit the root shell on successful run of start x
	if [ "$1" == 'start' -a "$success" == 'true' ];then
		if [ "$B_SM_INSTALL" != 'true' ];then
			# the failure case handels a weird thing when kill gives error
			if [ -n "$LOGIN_PID" ];then
				if [ -n "$defaultRunlevel" ];then
					init $defaultRunlevel && kill $LOGIN_PID && exit 0 || exit 1
				else
					kill $LOGIN_PID && exit 0 || exit 1
				fi
			else
				if [ -n "$defaultRunlevel" ];then
					echo "${E}No login Pid found to kill, starting init $defaultRunlevel and leaving root logged in.${N}"
					init $defaultRunlevel && exit 0 || exit 1
				else
					echo "${E}No login Pid found to kill, leaving root logged in.${N}"
					exit 0
				fi
			fi
		else
			exit 0 # smxi will handle the pid root kill
		fi
	fi
	eval $LOGUE
}

x_is_running()
{
	eval $LOGUS
	# we'll do one final X is running test here, note, handling a bunch of
	# different possible X detections in etch, lenny, and sid, then filtering out the grep
	local xIsRunning=$( ps aux | grep '/usr.*/X' | grep -vc 'grep' )

	if [ "$xIsRunning" -gt 0 ];then
		echo 0
	else
		echo 1
	fi
	eval $LOGUE
}

### -------------------------------------------------------------------
### xorg configuration (previously in sgfxi-lib-xorg)
### -------------------------------------------------------------------

move_x_conf()
{
	eval $LOGUS
	local x_full_bu="$EXXC-full-$( date +%Y-%m-%d-%H:%M:%S )"
	
	if [ -n "$( which $X_NAME )" ];then
		if [ "$( x_is_running )" -eq 0 ];then
			start_stop_x 'stop'
		fi
		if [ -f $EXXC ];then
			echo "${M}Moving ${C}$EXXC${M} to ${C}$x_full_bu${M}...${N}"
			mv -f $EXXC $x_full_bu
			echo "${S}Continuing to ${C}$EXXC${S} creation...${N}"
		else
			echo "${M}No ${C}$EXXC${M} file exists, continuing to ${C}$EXXC${M} creation...${N}"
		fi
	else
		log_function_data "A rebuild of xorg.conf is requested, but there is no X application to rebuild it with."
		error_handler 177
	fi
	eval $LOGUE
}

# newest xorg will have no xorg.conf file
create_x_conf()
{
	eval $LOGPS
	
	local bRepeat='false' opt='' options=''
	
	if [ ! -f $EXXC -a -n "$( echo $X_VERSION | grep -E '[1-2]\.[0-9]' )" -a -n "$( which $X_NAME )" ];then
		log_function_data "xorg is present, no xorg.conf file"
		
		echo $LINE
		if [ "$B_MOVE_X_CONF" == 'true' ];then
			echo "${S}Now it's time to make your new replacement ${C}$EXXC${S} file. "
		else
			echo "${S}You are running a new version of X but you have no ${C}$EXXC${S} file. "
		fi
		echo "${M}Would you like to create it now (uses ${C}X -configure${M} command)?"
		echo $LINE
		echo "${C}1 - yes-create-xorg-conf-file${M} - Create file and proceed.${N}"
		echo "${C}2 - quit${M} - Quit now, not sure if I should do this.${N}"
		echo $LINE
		options="yes-create-xorg-conf-file quit"
		select opt in $options
		do
			case $opt in
				yes-create-xorg-conf-file)
					echo "${S}Ok, creating your new ${C}$EXXC${S} file now...${N}"
					# X has already been stopped in this case ideally from move, but 
					# checking again to make sure. X command cannot be run with X running
					if [ "$( x_is_running )" -eq 0 ];then
						start_stop_x 'stop'
					fi
					# now double check and kill with precise errors to try to catch the cause
					# of failing xorg.conf generation
					if [ "$( x_is_running )" -eq 0 ];then
						error_handler 214
					fi
					$X_NAME -configure 2>>$LOG_FILE
					
					# getting error reports of missing file or error on file creation
					if [ -f /root/xorg.conf.new ];then
						echo "${S}Moving newly created ${C}xorg.conf${S} to ${C}$EXXC${S} now...${N}"
						mv -f /root/xorg.conf.new $EXXC
						log_function_data "xorg.conf created and mv to /etc/X11/"
					else
						# temporary debugger logging
# 						ls /root/xorg* >> $LOG_FILE
# 						ls /usr/local/bin/xorg* >> $LOG_FILE
# 						ls $(pwd)/xorg* >> $LOG_FILE
# 						error_handler 215

						# this is a short term hack, only required until X/xserver-xorg package
						# is fixed to be able to create an xorg.conf file.. In theory this should
						# simply vanish as soon as the xorg.conf is generated again, since this
						# case would then never exist.
						if [ ! -f $EXXC ];then
							log_function_data "touch created xorg.conf file because it was missing, X -configure error."
							touch $EXXC
						fi
					fi

					# this handles the case where nouveau was running, sgfxi was started, 
					# no xorg.conf was found, and the X -configure command defaults to nv
					if [ "$B_TESTING_5" == 'true' -a -n "$( lsmod | grep '^nouveau' )" ];then
						NATIVE_OVERRIDE='nouveau'
						update_xorgconf_driver_version
					fi
					if [ -f $EXXC ];then
						echo "${S}Ok, all done, continuing...${N}"
						log_function_data "xorg xorg.conf file generated"
					else
						error_handler 218
					fi
					;;
				quit)
					echo "${S}Ok, you'll have to figure out what to do manually then if you want to run $SCRIPT_NAME.${N}"
					exit 100 # need to exit with 100 to not trigger pid root kill in smxi
					;;
				*)
					echo "${W}Please select one of the options in the list, thank you.${N}"
					bRepeat='true'
					;;
			esac
			break
		done
		
		if [ "$bRepeat" == 'true' ];then
			create_x_conf
		fi
	elif [ ! -f $EXXC -a -z "$( which X )" ];then
		log_function_data "There is no xorg.conf file, and no X command to build one with."
		error_handler 244
	else
		log_function_data "xorg is present with xorg.conf file"
	fi
	eval $LOGPE
}

# create required section device:
create_section_device()
{
	eval $LOGUS
	# if this section is not present, create it
	if [ "$( grep -Esic 'Section[ \t]*"Device"' $EXXC )" -eq 0 ];then
		echo  >> $EXXC
		echo -e 'Section "Device"' >> $EXXC
		echo -e '\tIdentifier "Card0"' >> $EXXC
		# the vesa is a just a failsafe, the actual driver will be set in driver version
# 		echo -e '\tDriver "vesa"' >> $EXXC
# 		echo -e '\tBusID "PCI:'$BUS_ID'"' >> $EXXC
		echo 'EndSection' >> $EXXC
		echo  >> $EXXC
	fi
	# now fill it if needed
	eval $LOGUE
	create_driver_entry
}

# some rough code, will write driver / pciid if required,this is mainly for systems
# that are using the new xorg, and may not have a driver/busid entry.
# if all goes well, will only create a driver / busid entry if missing
create_driver_entry()
{
	eval $LOGUS
	# since this is set in the above function, it must exist, but I'll check to make sure
	local deviceLineNu=$( grep -Eisn 'Section[[:space:]]*"Device"' $EXXC | cut -d ':' -f 1 )

	# echo deviceLineNu: $deviceLineNu
	# make sure it's numeric, and that only one device section number was returned (space)
	if [ -n "$( grep -E '^[0-9]+$' <<< $deviceLineNu )" ];then
		# this is a trick to only grep within a block delimited by start/EndSection
		local isDriver=$( sed -n ''$deviceLineNu',/EndSection/ p' $EXXC | grep -Ei 'Driver[[:space:]]*".*"' )
		local isBusId=$( sed -n ''$deviceLineNu',/EndSection/ p' $EXXC | grep -Ei 'BusID[[:space:]]*".*"' )

		# echo isBusId: $isBusId
		# echo isDriver: $isDriver

		# the vesa is a just a failsafe, the actual driver will be set in driver version
		# this logic is complicated but seems to work, check the range in section device
		# line number to EndSection, then update the driver and busid if needed, as per
		# tests above already done
		# I'm not sure why -r didn't work, but it didn't in this case.
		if [ -z "$isDriver" ];then
			sed -i ''${deviceLineNu}',/EndSection/ s/Section[[:space:]]*"Device"/&\
\tDriver "vesa"/' $EXXC
		fi
		# only adding busid if driver is missing, otherwise mistakes will happen
		# xorg has a bug with bus id with hex, this is now handled in sgfxi
		# commented unless required by dual card presence, then uncommented
		if [ -z "$isBusId" ];then
			pcibusid_hex_to_dec
			sed -i ''${deviceLineNu}',/EndSection/ s/Driver[[:space:]]".*"/&\
\t#BusID "PCI:'${BUS_ID}'"/' $EXXC
		fi
	fi
	eval $LOGUE
}

# this will reset any hex in bus id string to avoid that new xorg failure to handle hex
pcibusid_hex_to_dec()
{
	eval $LOGUS

	local pt1=$( cut -d ':' -f 1 <<< $BUS_ID )
	local pt2=$( cut -d ':' -f 2 <<< $BUS_ID )
	local pt3=$( cut -d ':' -f 3 <<< $BUS_ID )
	local tempPt1='' tempPt2='' tempPt3=''

	let tempPt1=0x$pt1
	let tempPt2=0x$pt2
	let tempPt3=0x$pt3

	BUS_ID="$tempPt1:$tempPt2:$tempPt3"
	eval $LOGUE
}

# this will handle cases where user is changing from one card to another
update_xorgconf_driver_version()
{
	eval $LOGUS
	local driverName=$CARD

	if [ "$B_NATIVE_DRIVER" == 'true' ];then
		case $CARD in
			$FGLRX)
				driverName='ati'
				;;
			$INTEL)
				driverName='intel'
				;;
			$NVIDIA)
				driverName='nv'
				;;
		esac

		# this handles hard overrides to specific driver
		if [ -n "$NATIVE_OVERRIDE" ];then
			driverName=$NATIVE_OVERRIDE
		fi
	fi
	# not converting: i810-modesetting i740 i128: note openchrome just released in sid
	# previous: (i810|nvidia|nv|fglrx|ati|radeon|apm|iftv|fbdev|vesa)
	# these are all known xserver-xorg-video-xxxx drivers, plus nvidia and fglrx
	sed -i -r 's%^\s*Driver\s*"(apm|ark|ati|chips|cirrus|cyrix|fbdev|fglrx|glint|iftv|ivtv|i128|i740|i810|imstt|intel|mach64|mesa|mga|neomagic|newport|nouveau|nsc|nv|nvidia|openchrome|radeon|radeonhd|rendition|s3virge|s3|savage|siliconmotion|sis|sisusb|tdfx|tga|trident|tseng|v4l|vboxvideo|vesa|vga|via|vmware|voodoo)"%\tDriver\t"'$driverName'"%' $EXXC
	eval $LOGUE
}

# if required, create the Extensions section, then set it to what is needed for
# each specific argument/driver combination
check_extensions()
{
	eval $LOGUS
	local stateOn='enable' stateOff='disable' # default for nvidia
	local turnOff='' rendState=$stateOff compState=$stateOff aiglxString=''
	local compComment='#' rendComment='#'

	# for composite to be active, fglrx composite must be set to 0, not 1
	case $CARD in
		$FGLRX)
			#stateOn='Enable' # check into enable/disable syntax for fglrx/ati/radeon here
			#stateOff='Disable'
			rendState=$stateOff
			compState=$stateOff
			# this stuff needs to be Disabled explicitly, no comments for fglrx only.
			if [ "$B_NATIVE_DRIVER" != 'true' ];then
				rendComment='#'
				compComment=''
				#aiglxString='\n\tOption\t"AIGLX"\t"'$stateOff'"'
				if [ "$B_COMPOSITE" == 'true' ];then
					compState=$stateOn
				else
					compState=$stateOff
				fi
			fi
			;;
		$NVIDIA|$INTEL)
			if [ "$B_COMPOSITE" == 'true' ];then
				compState=$stateOn
				compComment=''
			else
				compState=$stateOff
			fi
			;;
	esac

	# clear out all previous extension stuff: note: fglrx composite, aiglx, render: off
	perl -pi -e 's/^[\s]*#*[\s]*Option\s*"Composite".*\n?//;
	s/^[\s]*#*[\s]*Option\s*"RENDER".*\n?//;
	s/^[\s]*#*[\s]*Option\s*"Render".*\n?//;
	s/^[\s]*#*[\s]*Option\s*"AIGLX".*\n?//;
	s/^[\s]*#*[\s]*Option\s*"Aiglx".*\n?//' $EXXC

	# if this section is not present, create it
	if [ "$( grep -sc 'Extensions' $EXXC )" -eq 0 ];then
		echo -e '\nSection "Extensions"' >> $EXXC
		echo 'EndSection' >> $EXXC
	fi
	# rebuild the extensions now
	perl -pi -e 's/^([\s]*Section\s*"Extensions")/\1\n'$compComment'\tOption      "Composite"\t"'$compState'"\n'$rendComment'\tOption      "RENDER"\t"'$rendState'"'$aiglxString'/' $EXXC
	eval $LOGUE
}

# resets xorg to basics, strips out all fglrx/nvidia specific stuff
clear_prep_xorg()
{
	eval $LOGUS
	perl -pi -e 's/^[\s]*Load\s*"GLcore"/#\tLoad\t"GLcore"/;
	s/^[\s]*Load\s*"dri"/#\tLoad\t"dri"/;
	s/^[\s]*#*[\s]*Load\s*"glx"/\tLoad\t"glx"/;
	s/^.*Load\s*"speedo".*\n?//;
	s/DefaultColorDepth.*/DefaultColorDepth 24/;
	s/^[\s]*Option\s*"sw_cursor"/\t#Option     "sw_cursor"/;
	s/^[\s]*#*[\s]*Option\s*"Composite".*/#\tOption\t"Composite"\t"1"/;
	s/^.*UseInternalAGPGART.*\n?//;
	s/^.*VideoOverlay.*\n?//;
	s/^.*OpenGLOverlay.*\n?//;
	s/^.*MonitorLayout.*\n?//;
	s/^.*IgnoreDisplayDevices.*\n?//;
	s/^.*Coolbits.*\n?//;
	s/^.*RenderAccel.*\n?//;
	s/^.*AllowGLXWithComposite.*\n?//;
	s/^.*RandRRotation.*\n?//;
	s/^.*AddARGBGLXVisuals.*\n?//;
	s/^.*DisableGLXRootClipping.*\n?//;
	s/^.*TripleBuffer.*\n?//;
	s/^.*UseEDID.*\n?//;
	s/^.*UseEdidFreqs.*\n?//;
	s/^.*DynamicTwinView.*\n?//;
	s/^.*AGPFastWrite.*\n?//;
	s/^.*AGPMode.*\n?//;
	s/^.*DynamicClocks.*\n?//;
	s/^.*ColorTiling.*\n?//;
	s/^.*EnablePageFlip.*\n?//;
	s/^.*TexturedXrender.*\n?//;
	s/^.*AccelMethod.*\n?//' $EXXC

	# turn on dri again for fglrx/intel, it's off for nvidia
	case $CARD in
		$FGLRX|$INTEL)
			perl -pi -e 's/^[\s]*#*[\s]*Load\s*"dri"/\tLoad\t"dri"/' $EXXC
			;;
	esac
	eval $LOGUE
}

remove_modelines()
{
	eval $LOGUS
	local removeThem='false'

	## this handles standard cases, always for fglrx, never for native ati/nv
	#   and whenever required by argument. I'll see if native ever needs them removed
	if [ "$CARD" == $FGLRX  -o "$B_REMOVE_MODELINES" == 'true' ];then
		if [ "$B_NATIVE_DRIVER" == 'true' -a "$B_REMOVE_MODELINES" == 'true' ];then
			removeThem='true'
		elif [ "$B_NATIVE_DRIVER" != 'true' ];then
			removeThem='true'
		fi
	fi
	if [ "$removeThem" == 'true' ];then
		perl -pi -e 's/^.*Mode.ine.*\n?//g' $EXXC
	fi
	eval $LOGUE
}

update_xorg()
{
	eval $LOGPS
	# this to second time stamp should help fix that old repeated .1st bug
	local timeStampXorg=$EXXC-bu-$( date +%Y-%m-%d-%H:%M:%S )
	local stateOn='enable' stateOff='disable' stateTrue='true' stateFalse='false'
	# nvidia stuff
	local rend=$stateOn twin=$stateTrue triple=$stateFalse
	#  note: putting a space in these subsitution patterns breaks perl -e
	local ignoreDisplay='Option\t"IgnoreDisplayDevices"\t"TV"\n\t'
	# fglrx stuff, we're using default agpart 'on' now instead
	local agpart='on' layout='AUTO,AUTO' allowGlx=''

	# this is set in rare cases of dual card early copy of xorg.conf
	if [ "$B_XORG_BACKED_UP" != 'true' ];then
		if [ ! -e $timeStampXorg ];then
			cp $EXXC $timeStampXorg
		fi
		log_function_data "xorg.conf was backed up to: $timeStampXorg"
		echo "${S}Backup copy of your previous version: ${C}$timeStampXorg${N}"
	fi
	echo "${S}Updating your ${C}$EXXC${S} file now...${N}"
	create_section_device # create section "device" if missing
	update_xorgconf_driver_version # will set to correct version
	clear_prep_xorg # bring xorg.conf to default condition
	check_extensions
	remove_modelines

	if [ "$B_NATIVE_DRIVER" != 'true' ];then
		case $CARD in
			$NVIDIA)
				# set any custom stuff here
				#[ "$B_RENDER_ACCEL" != 'true' ] && rend=$stateOff
				# switching off this, making default always off, watch for user feedback
# 				if [ "$B_DISPLAY_DEVICES" == 'true' ];then
					ignoreDisplay=''
# 				fi
				# this is legacy, new default is on
				#[ "$B_TWINVIEW" == 'true' ] && twin=$stateOn
				# triplebuffer can reduce 3d performance on cards with low graphics memory
				# 64 mb or less. Default is off/disable/0
				if [ "$B_TRIPLE_BUFFER" == 'true' ];then
					triple=$stateTrue
				fi
				# this should let 3D work again for older cards, 400 etc:
				# u
# 				if [ "$DRIVER_DEFAULT" == "$NV_LEGACY_1" ];then
# 					allowGlx='Option\t"AllowGLXWithComposite"\t"'$stateTrue'"\n\t'
# 				fi
				# note: coolbits requires an integer value
				# \n\tOption      "RandRRotation"\t"'$stateTrue'"
				# \n\tOption      "DynamicTwinView"\t"'$twin'"
				perl -pi -e 's/^([\s]*Driver\s*"nvidia")/\1\n\t'$ignoreDisplay$allowGlx'Option      "Coolbits"\t"1"\n\tOption      "AddARGBGLXVisuals"\t"'$stateTrue'"\n\tOption      "TripleBuffer"\t"'$triple'"/' $EXXC
				;;
			$FGLRX)
				# set any custom stuff here
				# only use fglrx internal agpart if not in system and never for 64 bit
				#[ "$( lsmod | grep -c 'agpgart' )" -gt 0 -o "$BITS" == '64' ] && agpart='no'

				# this is only for laptops
# 				if [ -n "$(find /proc/acpi/battery/ -mindepth 1 -type d 2>/dev/null)" ]
# 				then
# 					layout='LVDS,AUTO' # no space in string
# 				fi

				# \n\tOption      "UseInternalAGPGART" "'$agpart'"
				# \n\tOption      "VideoOverlay" "on"
				# \n\tOption      "MonitorLayout" "'$layout'
				perl -pi -e 's/^([\s]*Load\s*"extmod")/#\1\n\tSubSection  "extmod"\n\t  Option  "omit xfree86-dga"\n\tEndSubSection/' $EXXC

				#s/^([\s]*Driver\s*"fglrx")/\1\n\tOption      "UseInternalAGPGART" "'$agpart'"\n\tOption "TexturedXrender"/
				;;
		esac
	## Native ati/nv specific stuff
	else
		if [ "$CARD" == $INTEL ];then
			:
		# note: changed XAA to EXA
		elif [ "$NATIVE_OVERRIDE" == 'radeon' ];then
			# removed: Option  "AGPFastWrite"    "off"\n\tOption  "AGPMode" "4"\n\tOption   "ColorTiling" "on"
			perl -pi -e 's/^([\s]*Driver\s*"radeon")/\1\n\t\n\tOption  "DynamicClocks"   "on"\n\tOption   "EnablePageFlip" "on"\n\tOption   "AccelMethod" "EXA"/' $EXXC
		fi
	fi
	eval $LOGPE
}

########################################################################
#### OPTION HANDLER
########################################################################

# args: $1 - d (driver); f (fglrx data); n (nvidia data)
show_extra_data()
{
	local fullUrl='' ua='-U s-tools/sgfxi-data' uaFull='' dataFull='' dataType=''
	local scriptVersion='' scriptDate='' scriptRemoteVersion='' scriptRemoteDate=''
	local dataWorking='' bSysInfo='false'
	
	case $1 in
		d)
			fullUrl='http://smxi.org/sg/data/sg-drivers-23'
			uaFull="$ua.driver-data"
			dataType='Supported Drivers List'
			;;
		f)
			fullUrl='http://smxi.org/sm/upgrade-data/video_support_fglrx'
			uaFull="$ua.fglrx-status"
			dataType='FGLRX Status'
			bSysInfo='true'
			;;
		n)
			fullUrl='http://smxi.org/sm/upgrade-data/video_support_nvidia'
			uaFull="$ua.nvidia-status"
			dataType='Nvidia Status'
			bSysInfo='true'
			;;
		v)
			fullUrl=$SCRIPT_DOWNLOAD_VERSION
			uaFull="$ua.version-data"
			dataType="(latest) $SCRIPT_NAME version information"
			;;
	esac
	if [ "$bSysInfo" == 'true' ];then
		echo "${S}System Information :: Xorg Version: ${N}$X_VERSION ${S}:: Kernel: ${N}$( uname -r )"
	fi
	echo -n "${S}Retrieving live data... ${N}"
	dataFull="$( wget -q  $uaFull -O - $fullUrl 2>/dev/null )"
	case $1 in
		v)
# 			# don't need to run this if distro maintainer has set path
# 			if [ "$B_ALLOW_AUTO_UPDATE" == 'true' ];then
# 				check_set_distro
# 			fi
			dataWorking=$( grep 'sgfxi=' <<< "$dataFull" | cut -d '=' -f 2 )
			
			if [ -f $SCRIPT_HOME/$SCRIPT_NAME ];then
				scriptVersion=$( grep -Eo -m 1 "(version:).*" $SCRIPT_HOME/$SCRIPT_NAME | cut -d ' '  -f 2-4 )
				scriptDate=$( grep -Eo -m 1 '(Date:).*' $SCRIPT_HOME/$SCRIPT_NAME | cut -d ' ' -f 2-4 )
			else
				scriptVersion="Error: wrong path for $SCRIPT_NAME"
				scriptDate="Error: wrong path for $SCRIPT_NAME"
			fi
			scriptRemoteVersion=$( cut -d ':' -f 1 <<< $dataWorking )
			scriptRemoteDate=$( cut -d ':' -f 2 <<< $dataWorking )
			if [ "$scriptVersion" == "$scriptRemoteVersion" ];then
				dataFull="Remote Version: $scriptRemoteVersion is the same as Local Version: $scriptVersion" 
			else
				dataFull="The remote and local script versions are different:\nRemote Version: $scriptRemoteVersion\nRemote Date:    $scriptRemoteDate\n\nLocal Version:  $scriptVersion\nLocal Date:     $scriptDate"
			fi
			;;
	esac
	if [ -n "$dataFull" ];then
		echo "${S}Success! Here is the current $dataType:${N}"
		echo $LINE
		echo -e "$dataFull"
	else
		echo "${W}Failed!!${N}"
		echo $WLINE
		echo "${W}Unable to access the remote data file, exiting now, sorry."
		echo "This feature requires a working internet connection.${N}"
	fi
}

# keep this above getopts to keep it readable
# args: $1 if err or not, $2 extra data
show_options()
{
	local xVersion=$X_VERSION
	if [ -z $X_VERSION ];then
		xVersion="${W}NO SUPPORTED XORG!${N}"
	fi
	#local pattern='(1\.0-)?([0-9]{4}|1[0-9]{2}\.[0-9]{2}\.?[0-9]{0,2}):?'
	#local nvDefault=$( echo $NV_DEFAULT | sed -r 's/'$pattern'/\2 /g')
	local nvDefaults=$( echo $NV_VERSIONS | tr ':' ' ' | sed 's/1.0-//g' )
	#local nvVersions=$( echo "$NV_VERSIONS:$NV_OTHERS" | sed -r 's/'$pattern'/\2 /g')
	local nvVersions=$( echo "$NV_OTHERS" | tr ':' ' ' | sed 's/1.0-//g')
	#local nvQuadText='' nvQuad=$( echo $NV_QUAD | sed -r 's/'$pattern'/\2 /g')
	local nvQuadText='' nvQuad=$( echo $NV_QUAD | tr ':' ' ' | sed 's/1.0-//g')
	local fgDefault=$FG_DEFAULT
	local fgVersions=$( echo "$FG_VERSIONS:$FG_OTHERS" | sed 's/:/ /g')
	local nativeVersions=$( echo $NATIVE_OVERRIDE_SUPPORTED | sed 's/|/ /g' )
	local fgTesting='' nvTesting='' testingText='' fgDebianSid=''
	local counter=0 driverCount=0 skipOutput=''
	driverCount=$( wc -w <<< $nativeVersions )

	if [ "$B_DISTRO_FLAG" == 'true' ];then
		fgDebianSid='echo -e "'${W}'ATI: installer package '$fgDefault' is currently broken in Debian (works in Ubuntu). Script will default to: '$DISTRO_FGLRX${N}'"'
	else
		fgDebianSid='echo -e "fglrx:  default: '$fgDefault'		supported-drivers: '$fgVersions'"'
	fi

	if [ -n "$NV_TESTING" -a "$NV_TESTING" != "$NV_DEFAULT" ];then
		nvTesting='echo -e "nvidia: '$( echo $NV_TESTING | tr ':' ' ' | sed 's/[[:space:]][[:space:]]/ /g' )'"'
	fi
	if [ -n "$FG_TESTING" -a "$FG_TESTING" != "$FG_DEFAULT" ];then
		fgTesting='echo -e "fgrlx:\t'$FG_TESTING'"'
	fi
	if [ -n "$fgTesting" -o -n "$nvTesting" ];then
		testingText='echo "The following drivers are available for testing purposes:"'
	fi
	if [ -n "$NV_QUAD" -a "$NV_QUAD" != "$NV_DEFAULT" ];then
		nvQuadText='echo -e "Nvidia Quadroplex driver (automatically selected if you have a Quad card): '$nvQuad'"'
	fi

	if [ "$1" == 'err' ];then
		echo "${W}Sorry, one of your arguments is not a supported option.${N}"
		echo "Please check the following options and try again."
		echo $PLINE
	fi
	if [ -n "$DISPLAY" ];then
		echo "${W}While you can run this script in X, we recommend you run it in terminal.${N}"
		echo $PLINE
	fi
	echo "Script Requirements: Debian/Ubuntu/Arch/Fedora based systems."
	echo "Xorg version required: 7.1/1.1 or greater - Your X version: $xVersion"
	echo "Linux Kernel required: 2.6.18 or greater - Your kernel: $(uname -r)"
	echo $PLINE
	echo "'default(s):' - The driver installed automatically by $SCRIPT_NAME unless it is not supported by"
	echo "your card. Some older cards will force an override of this basic default. Script will"
	echo "print out what driver it will install when you start it up, with option to exit."
	echo
	echo "'supported-drivers:' choices require -o <see -o for correct syntax> to install>."
	echo "Fglrx:  default: $fgDefault"
	echo -n "Other supported-drivers: "
	counter=0
	driverCount=$( wc -w <<< $fgVersions )
	for i in $fgVersions
	do
		(( counter++ ))
		case $counter in
			12|28)
				echo "$i "
				echo -n ""
				;;
			$driverCount)
				echo "$i "
				;;
			*)
				echo -n "$i "
				;;
		esac
	done
	#echo "fglrx:  default: $fgDefault		supported-drivers: $fgVersions"
	echo "Nvidia: defaults (current + legacy - 3 2 1): $nvDefaults"
	echo -n "Other supported-drivers: "
	counter=0
	driverCount=$( wc -w <<< $nvVersions )
	for i in $nvVersions
	do
		(( counter++ ))
		case $counter in
			7|17)
				echo "$i "
				echo -n ""
				;;
			$driverCount)
				echo "$i "
				;;
			*)
				echo -n "$i "
				;;
		esac
	done
	eval $nvQuadText
	eval $testingText
	eval $nvTesting
	eval $fgTesting
	echo $PLINE
	echo "Script Options:"
	echo "-A Run the install non-interactively. Will not restart x at end."
	echo "-b Enable tripleBuffer (nvidia only). triplebuffer can reduce 3d performance on cards"
	echo "   with low graphics memory (64 mB or less). Default is disabled/off."
	echo "-B Use latest Beta Driver for your card type. Autodetects card type/beta driver (nVidia cards only)."
	echo "   If no beta driver is available, the current stable driver for your card type is used."
	echo "   (Also checks nvidia for live latest beta information, and replaces script defaults with newer if present)"
	echo "-c Force use of Xorg composite mode. Beryl/Compiz requires this for 3d. Old nvidia/ATI/Intel "
	echo "   cards not supported. Composite is default ON for newer nVidia cards (-c not required)."
	echo "-C Skip Xorg configuration. Only use this if your Xorg is already working with your driver."
	echo "   Main use is if you have dual card output and don't want xorg.conf changed."
	echo "-d Installs distro packaged nVidia/fglrx drivers. ATI/nVidia cards only (formerly -s)."
	echo "-D Build Distro (Debian/Ubuntu only) packages for fglrx with FGLRX binary run package,"
	echo "   then install them (formerly -F). Not recommended. Because of constant package"
	echo "   builder failures, the direct install method is now default."
# 	echo "-e Use experimental drivers (currently: xorg ati only)."
# 	echo "-E Adds extra experimental driver features. Currently libdrm2 things for ati."
	echo "-f Force option. Forces (re)install of your driver, bypasses module check/build (nVidia only)."
	echo "-h View this help menu."
	echo "-j Alternate text/output script colors. Requires this syntax: -j 0 (sets to monochrome )"
	echo "   -j 1 (default); -j 2 (pale); -j 3 (earthy); -j 4 (dark - for light console background)"
	echo "-k Build kernel module either for current kernel or another kernel (with -K <kernel version"
	echo "   Can be run in X. Simply builds the kernel module for that kernel, and does not remove"
	echo "   any other modules or drivers, or update $EXXC. Requires previous install"
	echo "   with sgfxi of the same driver to work. This feature only supports nVidia drivers."
	echo "   Hint: sgfxi -! 40 will install modules to all your non-running kernels automatically!"
	echo "-K Installs nVidia/fglrx driver for another kernel. Syntax: $SCRIPT_NAME -K 2.6.25-2"
	echo "   $SCRIPT_NAME will double check that the kernel exists (Debian/Ubuntu only)."
	echo "-L List current live driver or status data then exit. Requires extra argument: d to show current drivers;"
	echo "   n to show current nvidia support status; f to show current fglrx support status;"
	echo "   v to show current latest local + remote $SCRIPT_NAME svn/server version information."
	echo "-n Automatically installs correct native xorg nv, intel, or ati driver for your system."
	echo "   Cleans up old binary driver stuff, updates xorg.conf with new driver information,"
	echo "   and cleans nvidia and fgrlx stuff out of xorg.conf"
	echo "-N Force install of specific xorg driver. Syntax: $SCRIPT_NAME -N <driver> Ex: $SCRIPT_NAME -N radeonhd"
	echo -n "   Supported Xorg drivers: "
	counter=0
	driverCount=$( wc -w <<< $nativeVersions )
	for i in $nativeVersions
	do
		(( counter++ ))
		case $counter in
			12|25)
				echo " $i"
				echo -n "  "
				;;
			$driverCount)
				echo " $i"
				;;
			*)
				echo -n " $i"
				;;
		esac
	done
	echo "   Also configures xorg.conf as required. Full radeon xorg 3d configuration automatically."
	echo "-o Override default: install a specific driver, this is an absolute override - syntax:"
	echo "   -o 177.68 (for nVidia) or: -o 8-6 (for fglrx)"
	echo "-q Turns off composite mode. Default is ON for newer nVidia cards."
	echo "-Q Skip start X Question, automatically start X post driver install."
	echo "-r Remove mode lines from xorg.conf"
# 	echo "-t Enables dynamic twinview (nVidia only) - LEGACY, unused now. Default is on, enabled."
	echo "-R Skips self updating feature. No restart."
	
# 	echo "-S Skips automatic logout and X startup when script is run in standalone mode."
	echo "-U Forces $SCRIPT_NAME to update itself, must be root, but can be in x. Exits after."
	echo "-v Prints $SCRIPT_NAME current version information. Exits after."
	echo "-W Skip all wget downloads. Only use this to reinstall a driver that has already been"
	echo "   downloaded using $SCRIPT_NAME at least once previously."
	echo "-x Reverts to default libXvMC.so.1 for system instead of nVidia package (nVidia only)"
	echo "-X Use to skip auto X start/stop. Do not use this unless you have a good reason to not "
	echo "   want X start/stop tests to run. Gives start X option on completion if not in X."
	echo "-Y Clean script download and backup files. Shows a list of cleanup actions to carry out, including script uninstaller."
	echo "   Can be run in X, as root."
	echo "-z Backup and recreate xorg.conf using the command: X -configure (requires X/Xorg command)"
	echo "   Only use if you know what you are doing! This creates a simple, basic xorg.conf file."
# 	echo "-Z Skips connection test. Use this if $SCRIPT_NAME gives you connection failed error but"
# 	echo "   you are sure your connection is fine."
	echo $PLINE
	echo "Advanced Options :: Only for Specialized Cases"
	echo "-! 40 Create modules for all your kernels (nVidia only). Will loop through and test"
	echo "      each if can be made, then create the modules, excluding your running kernel."
	echo "      You must have already installed an nVidia driver with $SCRIPT_NAME to use -! 40"
	echo "      Note: if your installed driver is NOT the default $SCRIPT_NAME offers, you have to"
	echo "      use either the -o <driver number> OR the -B option (if you are using current beta driver)"
	echo "      as well as the -! 40 option. EG: to install beta to all kernels: $SCRIPT_NAME -B -! 40"
	if [ "$1" == 'full' ];then
		echo $PLINE
		echo "Developer and Testing Options (Advanced):"
		echo "-! 1 - Sets flag B_TESTING_1='true' - sets testing function data active."
		echo "-! 2 - Sets flag B_TESTING_2='true' - triggers exit after run package download/extract."
		echo "-! 3 - Sets flag B_SKIP_FUNCTION='true' to turn off functions for script testing."
		echo "-! 4 - Sets flags B_TESTING_1='true' and B_TESTING_2='true'."
		echo "-! 5 - Sets flags B_TESTING_1, B_TESTING_2, and B_SKIP_FUNCTION ='true'."
		echo "-! 6 - Sets flag B_TESTING_3='true' - overrides initial driver xorg/kernel support tests."
		echo "-! 7 - Sets flag B_TESTING_4='true' - overrides patch controls."
		echo "-! 8 - Sets flag B_TESTING_5='true' - activates beta/advanced development features for debugging."
		echo "-! 9 - Sets flag B_TESTING_6='true' - triggers experimental new distro support methods."
		echo "-! 10 - Triggers an update from the primary dev download server."
		echo "-! 11 - Triggers an update from svn branch one - if present, of course."
		echo "-! 12 - Triggers an update from svn branch two - if present, of course."
		echo "-! <http://......> - Triggers an update from whatever server you list."
		echo "-! 20 - Uses patch from svn branch one server (must be in branch/one/patches)."
		echo "-! 21 - Uses patch from svn branch two server (must be in branch/two/patches)."
		echo "-! 30 - Backup, download, replace, xorg.conf with basic Debian xorg.conf version (legacy, don't use)."
		echo "        Use X -configure instead to redo your xorg, or -z option in $SCRIPT_NAME."
		echo "-! 31 - Backup, download, replace, xorg.conf with basic xorg.conf version(legacy, don't use)."
		echo "        Use X -configure instead to redo your xorg, or -z option in $SCRIPT_NAME."
		echo "-p Print currently supported drivers, <default>:<latest>:<legacy1>:<legacy2>"
		echo "   then exit the script without doing the driver download/install."
		echo "-! 121  - When used with -p, will use the live driver list from smxi.org"
		echo "          instead of the drivers taken from the local user $SCRIPT_NAME values."
	fi
	echo
	if [ "$1" == 'err' ];then
		exit 1
	else
		exit 0
	fi
}

# args: $1 - "$@"
get_options()
{
	local opt=''

	while getopts AbBcCdDeEfFGhHj:kK:L:nN:o:pP:QrRsStUvWXxYzZ!: opt
	do
		case $opt in
			A) B_AUTORUN='true'
				START_OPTIONS=$START_OPTIONS' -A'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -A - Autorun is selected\n"
				;;
			b) B_TRIPLE_BUFFER='true'
				START_OPTIONS=$START_OPTIONS' -b'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -b - TripleBuffer is on (nVidia only)\n"
				;;
			B)	B_USE_BETA='true'
				START_OPTIONS=$START_OPTIONS' -B'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -B - Use Beta Driver (nVidia only. Only if available)\n"
				;;
			c) B_COMPOSITE='true'
				START_OPTIONS=$START_OPTIONS' -c'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -c - Force composite flag on. Does not work with legacy nVidia driver\n       Composite is default ON for newer nVidia cards (no -c required).\n       Switch composite OFF with: -q\n"
				;;
			C) B_SKIP_CONFIG='true'
				START_OPTIONS=$START_OPTIONS' -C'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -C - Xorg.conf will not be modified by this script.\n"
				;;
			d)	B_USE_DISTRO_DRIVER='true'
				B_FGLRX_DIRECT=''
				START_OPTIONS=$START_OPTIONS' -d'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -d - Install distro packaged driver.\n"
				;;
			D)	B_FGLRX_DEB_BUILDER='true'
				B_FGLRX_DIRECT=''
				START_OPTIONS=$START_OPTIONS' -D'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -D - Using FGLRX Distro package builder install. Not reliable, but try if you want.\n       Builds/Installs packages for distro from downloaded fglrx run file.\n"
				;;
	# 		e) B_EXPERIMENTAL='true'
	# 			START_OPTIONS=$START_OPTIONS' -e'
	# 			;;
	# 		E) B_EXTRA_EXPERIMENTAL='true'
	# 			START_OPTIONS=$START_OPTIONS' -E'
	# 			;;
			f)	B_FORCE_OPTION='true'
				START_OPTIONS=$START_OPTIONS' -f'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -f - You are using the forced override option. This will bypass kernel module\n       check/build and force reinstall of your driver (nVidia only).\n"
				;;
			F)	B_FGLRX_DEB_BUILDER='true'
				B_FGLRX_DIRECT=''
				START_OPTIONS=$START_OPTIONS' -F'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -F - Using FGLRX package builder install. Not reliable, but try if you want.\n       -F is deprecated, please use -D instead in the future.\n"
				;;
			G)	B_GUI_MODE='true'
				B_SKIP_X_TEST='true'
				START_OPTIONS=$START_OPTIONS' -G'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -G - Gui mode. Run in X. For nVidia, passes --no-x-check flag to nvidia installer\n       . Not reliable, but try if you want.\n"
				;;
			j)	if [ -n "$( grep -E '^[0-4]$' <<< $OPTARG )" ];then
					SCRIPT_COLORS=$OPTARG
					START_OPTIONS=$START_OPTIONS" -j $OPTARG"
					# no reason to reset the colors if they are default
					if [ "$SCRIPT_COLORS" != 1 ];then
						START_OPTIONS=$START_OPTIONS" -j $SCRIPT_COLORS"
						set_script_colors
					fi
				else
					error_handler 228 $OPTARG
				fi
				;;
			k)	B_KERNEL_MODULE_ONLY='true'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -k - building nvidia kernel module using previously installed driver\n"
				START_OPTIONS=$START_OPTIONS" -k "
				;;
			K)	INSTALL_TO_KERNEL="$OPTARG"
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -K - You are installing a graphic driver onto the kernel: ${C}$INSTALL_TO_KERNEL${S}\n"
				test_install_kernel_version
				START_OPTIONS=$START_OPTIONS" -K $OPTARG"
				;;
			L)	if [ -n "$( grep -E '^[dfnv]$' <<< $OPTARG )" ];then
					show_extra_data "$OPTARG"
					exit 0
				else
					error_handler 228 $OPTARG
				fi
				;;
			n) B_NATIVE_DRIVER='true'
				START_OPTIONS=$START_OPTIONS' -n'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -n - Auto install of native xorg intel, nvidia, 3dfx, or ati drivers.\n"
				;;
			N)
				if [ -n $( grep -E '('$NATIVE_OVERRIDE_SUPPORTED')' <<< $NATIVE_OVERRIDE ) ];then
					NATIVE_OVERRIDE="$OPTARG"
					B_NATIVE_DRIVER='true'
					START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -N - Native driver custom install. You have requested to install the xorg driver: $NATIVE_OVERRIDE\n"
					START_OPTIONS=$START_OPTIONS" -N $OPTARG"
				else
					error_handler 237 $NATIVE_OVERRIDE
				fi
				;;
			o) DRIVER_OVERRIDE="$OPTARG"
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -o - Driver override. Forces install of this driver: $DRIVER_OVERRIDE (nVidia|ATI fglrx only)\n"
				START_OPTIONS=$START_OPTIONS" -o $OPTARG"
				;;
			p) B_PRINT_VER='true'
				START_OPTIONS=$START_OPTIONS' -p'
				;;
			P)	if [ -n $( grep -E '^(apt-get|aptitude)$' <<< $OPTARG ) ];then
					PACKAGE_MANAGER=$OPTARG
					APT_TYPE=$OPTARG
					START_OPTIONS=$START_OPTIONS" -P $OPTARG"
				else
					error_handler 228 $OPTARG
				fi
				;;
			q)	B_FORCE_NO_COMPOSITE='true'
				B_COMPOSITE='false'
				START_OPTIONS=$START_OPTIONS' -q'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -q - Turn off default ON composite flag (nVidia only).\n"
				;;
			Q)	B_SKIP_X_QUESTION='true'
				START_OPTIONS=$START_OPTIONS' -Q'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -Q - X will start automatically when the driver install is finished.\n"
				;;
			r) B_REMOVE_MODELINES='true'
				START_OPTIONS=$START_OPTIONS' -r'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -r - Remove modelines in xorg.conf (ATI only).\n"
				;;
			R) B_SKIP_RESTART='true'
				;;
			# deprecated but leaving to not break existing methods
			s)	B_USE_DISTRO_DRIVER='true'
				B_FGLRX_DIRECT=''
				START_OPTIONS=$START_OPTIONS' -s'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -s - Install distro packaged driver. Deprecated. Please use -d instead\n"
				;;
			S) B_SKIP_AUTOSTART='true'
				START_OPTIONS=$START_OPTIONS' -S'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -S - Deprecated, not used. Skip autostart of X/kde.\n"
				;;
			t) B_TWINVIEW='true'
				START_OPTIONS=$START_OPTIONS' -t'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -t - twinview on: this is deprecated. Always sets for twinview (nVidia only)\n"
				;;
			U) B_FORCE_UPDATE='true'
				;;
			v) print_information
				exit 0
				;;
			W) B_SKIP_WGET='true'
				START_OPTIONS=$START_OPTIONS' -W'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -W - Skip wget downloads. Only use if you are having problems connecting\n    but you have the current driver downloaded already.\n"
				;;
			x) B_NO_XVMC='true' # because two flags are required to use nvidia xvmc, this is fine
				START_OPTIONS=$START_OPTIONS' -x'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -x - Skip nVidia xvmc setup. (nVidia only)\n"
				;;
			X) B_SKIP_X_TEST='true'
				START_OPTIONS=$START_OPTIONS' -X'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -X - Skip the test for X/KDE. Only use if you know what you are doing!\n"
				;;
			Y)	clean_script_data
				;;
			z)	if [ -z "$DISPLAY" ];then
					B_MOVE_X_CONF='true'
					START_OPTIONS=$START_OPTIONS' -z'
					START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -z - Backup and recreate xorg.conf using the command: X -configure\nOnly use if you know what you are doing!\n"
				else
					error_handler 250
				fi
				;;
			Z) B_SKIP_CONNECT='true'
				START_OPTIONS=$START_OPTIONS' -ZW'
				START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -Z - Deprecated, use -R to skip script update; use -W to skip all downloads.\n"
				;;
			h) show_options
				;;
			H)	show_options 'full'
				;;
			## debuggers and testing options
			!)	# test for various supported methods
				skipOutput=''
				case $OPTARG in
					1)	B_TESTING_1='true'
						;;
					2)	B_TESTING_2='true'
						;;
					3)	B_SKIP_FUNCTION='true'
						;;
					4)	B_TESTING_1='true'
						B_TESTING_2='true'
						;;
					5)	B_TESTING_1='true'
						B_TESTING_2='true'
						B_SKIP_FUNCTION='true'
						;;
					6)	B_TESTING_3='true'
						;;
					7)	B_TESTING_4='true'
						;;
					8)	B_TESTING_5='true'
						;;
					9)	B_TESTING_6='true'
						;;
					10)
						cd $SCRIPT_HOME
						check_root
						check_set_distro
						check_update_script "$SCRIPT_NAME" "$SCRIPT_DOWNLOAD_DEV" 'dev server'
						;;
					11)
						cd $SCRIPT_HOME
						check_root
						check_set_distro
						check_update_script "$SCRIPT_NAME" "$SCRIPT_DOWNLOAD_BRANCH_1" 'svn: branch one server'
						;;
					12)
						cd $SCRIPT_HOME
						check_root
						check_set_distro
						check_update_script "$SCRIPT_NAME" "$SCRIPT_DOWNLOAD_BRANCH_2" 'svn: branch two server'
						;;
					http*)
						cd $SCRIPT_HOME
						check_root
						check_set_distro
						check_update_script "$SCRIPT_NAME" "$OPTARG" 'alt server'
						;;
					20)
						PATCH_DOWNLOAD="$SCRIPT_DOWNLOAD_BRANCH_1"
						;;
					21)
						PATCH_DOWNLOAD="$SCRIPT_DOWNLOAD_BRANCH_2"
						;;
					# let these run in X
					30)
						cd $SCRIPT_HOME
						check_root
						check_set_distro
						check_update_script "dm-1-xorg-conf" "$SCRIPT_DOWNLOAD_DATA" 'main server'
						exit 0
						;;
					31)
						cd $SCRIPT_HOME
						check_root
						check_set_distro
						check_update_script "sm-1-xorg-conf" "$SCRIPT_DOWNLOAD_DATA" 'main server'
						exit 0
						;;
					40)
						B_BUILD_KERNEL_MODULES='true'
						;;
					120)
						B_SM_INSTALL='true'
						S=${CALLER_DEF} # change standard text color to caller standard text
						skipOutput='true'
						;;
					121)
						B_GET_LIVE_DRIVERS='true'
						;;
					*)	
						error_handler 178 "$OPTARG"
						;;
				esac
				START_OPTIONS="$START_OPTIONS -! $OPTARG"
				if [ "$skipOutput" != 'true' ];then
					START_OPTIONS_PRINT="$START_OPTIONS_PRINT  -! $OPTARG - You are using an advanced Testing option. Only use this if you know what you are doing!\n"
				fi
				;;
			*) show_options err
				;;
		esac
	done
	#in case -n is used too - note: this will never be true, have to fix this one
	if [ "$B_NATIVE_DRIVER" == "true" -a -n "$INSTALL_TO_KERNEL" ];then
		echo "${W}WARNING: -n will uninstall binary drivers to all the kernels, not just $KERNEL_VERSION${N}"
	fi
}

########################################################################
#### MAIN: EXECUTE
########################################################################

# this must be set before anything else runs in script, -j will reset to no colors
set_script_colors $COLOR_DEFAULT
# set all options
get_options "$@"
# this exits when it's done if triggered
if [ "$B_BUILD_KERNEL_MODULES" == 'true' ];then
	check_set_distro ## need to know what it is for some tests
	install_modules_to_all_kernels
fi
# Get kernel string stuff, no need to rerun this after it's been set in options
if [ -z "$INSTALL_TO_KERNEL" ];then
	kernel_string_info
fi

## if this exits with error, no lib files will be downloaded
if [ "$B_SKIP_FUNCTION" != 'true' ];then
	basic_startup_tests
fi

## update everything, restart if not run from smxi
if [ "$B_ALLOW_AUTO_UPDATE" == 'true' -a "$B_SKIP_RESTART" != 'true' -a "$B_SM_INSTALL" != 'true' -a "$B_SKIP_FUNCTION" != 'true' -a "$B_SKIP_WGET" != 'true' -a "$B_PRINT_VER" != 'true'  ];then
	check_update_script $SCRIPT_NAME "$SCRIPT_DOWNLOAD" 'default server'
fi

set_test_data # this will set other test data for debugging

if [ "$B_PRINT_VER" != 'true' ];then
	# test for multiple video cards and select only one
	if [ "$CARD_COUNT" -gt 1 ];then
		# handle no xorg.conf with new X situation, only create xorg.conf
		# if > 2 cards prior to testing for supported cards
		if [ "$B_SKIP_FUNCTION" != 'true' ];then
			create_x_conf
		fi
		select_card
	fi
	print_information
fi

if [ "$B_GET_LIVE_DRIVERS" == 'true' -a "$B_PRINT_VER" == 'true' ];then
	reset_using_live_driver_data
fi

## this is separate so card can get set first for native installer
set_card

if [ "$B_NATIVE_DRIVER" != 'true' ];then
	detect_card_version
fi

# this needs to go before logging starts so we know what the package manager is
if [ "$B_PRINT_VER" != 'true' -a -z "$PACKAGE_MANAGER" -a "$B_SM_INSTALL" != 'true' -a "$B_AUTORUN" != 'true' ];then
	check_apt_aptitude
fi

## This has to run after card version detection to log that data
## don't log the first start if restart/print output happens
if [ "$B_PRINT_VER" != 'true' ];then
	create_log
fi
# need to handle new xorg no xorg.conf systems
# no need to create this if the card isn't supported, so this comes
# after print info and log start unless > 1 card detected
if [ "$B_PRINT_VER" != 'true' -a "$B_SKIP_FUNCTION" != 'true' ];then
	if [ "$B_MOVE_X_CONF" == 'true' ];then
		move_x_conf
	fi
	create_x_conf
fi

# we'll need to force an initial update on fresh apt type installs for header
# checks and other package checks.
if [ "$B_SKIP_FUNCTION" != 'true' -a "$B_PRINT_VER" != 'true' -a "$B_SM_INSTALL" != 'true' ];then
	check_package_manager_updated
fi
# this exits when done
if [ "$B_NATIVE_DRIVER" == 'true' ];then
	install_native_driver
fi
## ready to set the data for version/system info
if [ "$B_USE_DISTRO_DRIVER" != 'true' ];then
	check_supported_driver # make sure user entered data is correct
	set_cpu_data
fi
# needs to be out to give print version, if print out driver data, exits after.
set_driver_install_version

if [ "$B_NATIVE_DRIVER" != 'true' ];then
	# make sure user has kernel headers, to avoid running unneeded clean up or prep
	check_kernel_headers
fi

if [ "$B_USE_DISTRO_DRIVER" != 'true' ];then
	create_data_storage
	check_run_package_tools
	set_download_info # also triggers the download / extract function
	# need to make sure this doesn't run for module build component
	if [ "$B_SKIP_INSTALL" != 'true' ];then
		if [ "$B_KERNEL_MODULE_ONLY" == 'true' ];then
			# this will run by itself because it's just some tests and a module rebuild
			# when it's done it will simply exit, no reboot or desktop start is required.
			build_kernel_module_only 'direct'
		else
			# this is going to run either the fglrx or nvidia patch library file function
			# must be after set_driver_install_version for output of data to smxi
			# note this must occur before binary driver install
			set_install_directory
			run_driver_patches
		fi
		if [ "$B_TESTING_2" == 'true' ];then
			exit 0 # this is just to test up to download/extract point
		fi
	fi
fi
# need to make sure this doesn't run for module build component
if [ "$B_SKIP_INSTALL" != 'true' ];then	
	x_start_stop_master stop
	
	if [ "$B_SKIP_FUNCTION" != 'true' -a "$B_PRINT_VER" != 'true' -a "$B_NATIVE_DRIVER" != 'true' ];then
		check_driver_install_tools
	fi
	prep_install
	# for testing/debugging and alt driver/card download testing,
	# I don't want to remove this stuff from system
	if [ "$B_SKIP_FUNCTION" != 'true' ];then
		preinstall_cleanup
	fi
	
	## both have same function name, so no detection is required, we did it already
	if [ "$B_USE_DISTRO_DRIVER" != 'true' ];then
		run_driver_installer
		post_installer_steps
		if [ "$B_FGLRX_DEB_BUILDER" == 'true' ];then
			install_fglrx_debs
		fi
	else
		update_to_nonfree_sources
		install_distro_drivers
	fi
	if [ "$B_SKIP_CONFIG" != 'true' ];then
		update_xorg
	fi
	final_install_steps
	
	x_start_stop_master start
fi

###**EOF**###